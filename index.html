<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>SHEEPLY Sleep ‚Äì —Å—á–∏—Ç–∞–π –æ–≤–µ—Ü</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="theme-color" content="#bde0ff" />
  <!-- –®—Ä–∏—Ñ—Ç—ã: –ø–∏–∫—Å–µ–ª—å–Ω—ã–π –¥–ª—è —Å—á—ë—Ç–∞ + —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –¥–ª—è —Ç–µ–∫—Å—Ç–∞ -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      background: #bde0ff;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #0f172a;
      overflow: hidden;
    }

    #app {
      max-width: 480px;
      margin: 0 auto;
      height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 10px;
      gap: 8px;
    }

    #header {
      flex-shrink: 0;
      padding: 10px 14px;
      border-radius: 18px;
      background: linear-gradient(145deg, #ffffff, #e0f2ff);
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.25);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #title {
      font-family: "Press Start 2P", system-ui, sans-serif;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #0f172a;
    }

    #subtitle {
      font-size: 12px;
      color: #4b5563;
    }

    #stats {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .pill {
      font-family: "Press Start 2P", system-ui, sans-serif;
      font-size: 9px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.16);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      color: #0f172a;
    }

    #gameCard {
      flex: 1;
      min-height: 0;
      border-radius: 22px;
      background: #bde0ff;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.45);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    #canvasWrapper {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: manipulation;
      image-rendering: pixelated;
    }

    #hint {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 11px;
      background: rgba(15, 23, 42, 0.6);
      color: #f9fafb;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      backdrop-filter: blur(12px);
      border: 1px solid rgba(191, 219, 254, 0.9);
      z-index: 5;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(15, 23, 42, 0.92);
      z-index: 10;
      color: #f9fafb;
    }

    .overlay-inner {
      width: 90%;
      max-width: 320px;
      padding: 16px 14px;
      border-radius: 18px;
      background: radial-gradient(circle at top, #0f172a, #020617);
      border: 1px solid rgba(148, 163, 184, 0.7);
      text-align: center;
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.75);
    }

    .overlay-inner h2 {
      font-family: "Press Start 2P", system-ui, sans-serif;
      font-size: 12px;
      margin-bottom: 10px;
    }

    .overlay-inner p {
      font-size: 12px;
      margin-bottom: 10px;
      color: #e5e7eb;
    }

    .overlay-inner button {
      margin-top: 6px;
      border: none;
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 11px;
      font-weight: 600;
      font-family: "Inter", system-ui, sans-serif;
      cursor: pointer;
      background: linear-gradient(135deg, #38bdf8, #22c55e);
      color: #0f172a;
      box-shadow: 0 10px 25px rgba(59, 130, 246, 0.7);
    }

    .overlay-inner button:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 5px 14px rgba(59, 130, 246, 0.7);
    }

    .hidden {
      display: none;
    }

    @media (max-width: 400px) {
      #title { font-size: 10px; }
      .pill { font-size: 8px; }
      .overlay-inner h2 { font-size: 11px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <header id="header">
      <div id="title">SHEEPLY ‚Äì COUNT SHEEP</div>
      <div id="subtitle">–¢–∞–ø–∞–π –ø–æ –æ–≤–µ—á–∫–µ –Ω–∞ –∫—Ä–æ–≤–∞—Ç–∏. –ö–∞–∂–¥—ã–µ 100 –∫–ª–∏–∫–æ–≤ ‚Äî –Ω–æ–≤—ã–π —Ñ–æ–Ω. –ù–∞ 3000 –æ–≤–µ—Ü SHEEPLY –∑–∞—Å—ã–ø–∞–µ—Ç üåô</div>
      <div id="stats">
        <span class="pill">–û–í–¶–´: <span id="scoreValue">0</span></span>
        <span class="pill">–†–ï–ö–û–†–î: <span id="bestValue">0</span></span>
        <span class="pill">–ö–û–ú–ë–û: <span id="comboValue">0</span></span>
      </div>
    </header>

    <main id="gameCard">
      <div id="canvasWrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="hint">–ù–∞–∂–∏–º–∞–π –Ω–∞ –æ–≤—Ü—É üêë, —á—Ç–æ–±—ã —Å—á–∏—Ç–∞—Ç—å –æ–≤–µ—Ü –ø–µ—Ä–µ–¥ —Å–Ω–æ–º</div>

        <div id="sleepOverlay" class="overlay hidden">
          <div class="overlay-inner">
            <h2>–¢—ã —É—Å–Ω—É–ª üò¥</h2>
            <p>–¢—ã –Ω–∞—Å—á–∏—Ç–∞–ª <span id="sleepScore">0</span> –æ–≤–µ—Ü. SHEEPLY —Å–ª–∞–¥–∫–æ —Å–ø–∏—Ç –Ω–∞ –∫—Ä–æ–≤–∞—Ç–∏.</p>
            <button id="restartBtn">–°—á—ë—Ç –ø–æ –Ω–æ–≤–æ–π</button>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("scoreValue");
    const bestEl = document.getElementById("bestValue");
    const comboEl = document.getElementById("comboValue");
    const hintEl = document.getElementById("hint");
    const sleepOverlay = document.getElementById("sleepOverlay");
    const sleepScoreEl = document.getElementById("sleepScore");
    const restartBtn = document.getElementById("restartBtn");

    let w = 0, h = 0;

    const backgrounds = [
      { name: "–£—Ç—Ä–æ", skyTop: "#bde0ff", skyBottom: "#ffffff", stars: false },
      { name: "–î–µ–Ω—å", skyTop: "#7dd3fc", skyBottom: "#e0f2ff", stars: false },
      { name: "–ó–∞–∫–∞—Ç", skyTop: "#fb7185", skyBottom: "#fecaca", stars: false },
      { name: "–ù–æ—á—å", skyTop: "#1e293b", skyBottom: "#020617", stars: true },
      { name: "–ì–ª—É–±–æ–∫–∞—è –Ω–æ—á—å", skyTop: "#020617", skyBottom: "#020617", stars: true }
    ];

    const state = {
      score: 0,
      best: 0,
      combo: 0,
      jumpTime: 0,
      jumpDuration: 260,
      wavePhase: 0,
      sheep: { x: 0, y: 0, size: 80 },
      bedTop: 0,
      zzz: [],
      lastTs: 0,
      asleep: false
    };

    // —Ä–µ–∫–æ—Ä–¥
    try {
      const saved = localStorage.getItem("sheep_sleep_best");
      if (saved) state.best = parseInt(saved, 10) || 0;
    } catch (_) {}
    bestEl.textContent = state.best;

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      w = rect.width;
      h = rect.height;

      state.sheep.size = Math.min(w, h) * 0.25;
      const unit = state.sheep.size / 8;

      state.bedTop = h - unit * 5;          // –≤–µ—Ä—Ö –∫—Ä–æ–≤–∞—Ç–∏ –±–ª–∏–∂–µ –∫ –Ω–∏–∑—É
      state.sheep.y = state.bedTop - state.sheep.size * 0.5;
      state.sheep.x = w / 2;
    }

    window.addEventListener("resize", resizeCanvas);

    function updateScoreViews() {
      scoreEl.textContent = state.score;
      bestEl.textContent = state.best;
      comboEl.textContent = state.combo;
    }

    function handleTap(isAuto = false) {
      if (state.asleep) return; // –∫–æ–≥–¥–∞ —É—Å–Ω—É–ª ‚Äî –±–æ–ª—å—à–µ –Ω–µ —Å—á–∏—Ç–∞–µ–º
      if (!isAuto) hintEl.style.display = "none";

      state.score += 1;
      state.combo += 1;
      if (state.score > state.best) {
        state.best = state.score;
        try {
          localStorage.setItem("sheep_sleep_best", String(state.best));
        } catch (_) {}
      }
      state.jumpTime = state.jumpDuration;
      spawnZzz();
      updateScoreViews();

      // —Å–º–µ–Ω–∞ —Ñ–æ–Ω–∞ –∫–∞–∂–¥—ã–µ 100 –∫–ª–∏–∫–æ–≤
      // (–ø—Ä–æ—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥—Ä—É–≥–æ–π –∏–Ω–¥–µ–∫—Å –ø—Ä–∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–µ —á–µ—Ä–µ–∑ score)
      // —Ä–µ–∂–∏–º "–∑–∞—Å–Ω—É–ª" –Ω–∞ 3000 –æ–≤–µ—Ü
      if (state.score >= 3000 && !state.asleep) {
        state.asleep = true;
        sleepScoreEl.textContent = state.score;
        sleepOverlay.classList.remove("hidden");
      }
    }

    function isPointInSheep(x, y) {
      const dx = x - state.sheep.x;
      const dy = y - state.sheep.y;
      const r = state.sheep.size * 0.7;
      return dx * dx + dy * dy <= r * r;
    }

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (isPointInSheep(x, y)) {
        handleTap(false);
      } else {
        state.combo = 0;
        comboEl.textContent = "0";
      }
    });

    canvas.addEventListener("touchstart", (e) => {
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = t.clientX - rect.left;
      const y = t.clientY - rect.top;
      if (isPointInSheep(x, y)) {
        handleTap(false);
      } else {
        state.combo = 0;
        comboEl.textContent = "0";
      }
    }, { passive: true });

    restartBtn.addEventListener("click", () => {
      state.score = 0;
      state.combo = 0;
      state.zzz = [];
      state.asleep = false;
      updateScoreViews();
      sleepOverlay.classList.add("hidden");
      hintEl.style.display = "block";
    });

    // Zzz —á–∞—Å—Ç–∏—Ü—ã
    function spawnZzz() {
      state.zzz.push({
        x: state.sheep.x + (Math.random() - 0.5) * state.sheep.size * 0.4,
        y: state.sheep.y - state.sheep.size * 0.7,
        age: 0,
        life: 1200 + Math.random() * 600,
        char: Math.random() < 0.5 ? "Z" : "z",
        speedY: -0.03 - Math.random() * 0.03
      });
    }

    function updateZzz(dt) {
      for (let i = state.zzz.length - 1; i >= 0; i--) {
        const z = state.zzz[i];
        z.age += dt;
        z.y += z.speedY * dt;
        if (z.age > z.life) {
          state.zzz.splice(i, 1);
        }
      }
    }

    function drawZzz() {
      ctx.save();
      ctx.font = `${Math.round(state.sheep.size * 0.3)}px "Press Start 2P"`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const z of state.zzz) {
        const alpha = 1 - z.age / z.life;
        ctx.globalAlpha = Math.max(0, alpha);
        ctx.fillStyle = "#ffffff";
        ctx.fillText(z.char, z.x, z.y);
      }
      ctx.restore();
    }

    // –§–æ–Ω —Å –∫—Ä–æ–≤–∞—Ç—å—é
    function drawBackground() {
      const bgIndex = Math.min(
        Math.floor(state.score / 100),
        backgrounds.length - 1
      );
      const theme = backgrounds[bgIndex];

      const skyHeight = state.bedTop - state.sheep.size * 0.2;

      const grad = ctx.createLinearGradient(0, 0, 0, skyHeight);
      grad.addColorStop(0, theme.skyTop);
      grad.addColorStop(1, theme.skyBottom);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, skyHeight);

      // –∑–≤—ë–∑–¥—ã –¥–ª—è –Ω–æ—á–Ω—ã—Ö —Ç–µ–º
      if (theme.stars) {
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        for (let i = 0; i < 30; i++) {
          const sx = (i * 73) % w;
          const sy = (i * 41) % (skyHeight * 0.7);
          ctx.fillRect(sx, sy, 1, 1);
        }
      }

      // –ø–∏–∫—Å–µ–ª—å–Ω—ã–µ –æ–±–ª–∞–∫–∞ (–Ω–∞ –¥–Ω–µ–≤–Ω—ã—Ö)
      if (!theme.stars) {
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        const t = state.wavePhase * 0.001;
        drawPixelCloud(w * 0.2 + Math.sin(t) * 18, skyHeight * 0.3, 40);
        drawPixelCloud(w * 0.75 + Math.cos(t * 0.7) * 22, skyHeight * 0.18, 50);
      }

      // –∫—Ä–æ–≤–∞—Ç—å
      const unit = state.sheep.size / 8;
      const bedWidth = state.sheep.size * 3;
      const bedX = state.sheep.x - bedWidth / 2;
      const bedTop = state.bedTop;
      const bedHeight = unit * 3;

      // –Ω–æ–∂–∫–∏ –∫—Ä–æ–≤–∞—Ç–∏
      ctx.fillStyle = "#92400e";
      ctx.fillRect(bedX - unit * 0.4, bedTop + bedHeight, unit * 1.2, unit * 3);
      ctx.fillRect(bedX + bedWidth - unit * 0.8, bedTop + bedHeight, unit * 1.2, unit * 3);

      // —Ä–∞–º–∞
      ctx.fillStyle = "#b45309";
      ctx.fillRect(bedX - unit * 0.5, bedTop, bedWidth + unit, bedHeight);

      // –º–∞—Ç—Ä–∞—Å
      ctx.fillStyle = "#e0f2fe";
      ctx.fillRect(bedX, bedTop - unit * 1.4, bedWidth, unit * 1.4);

      ctx.fillStyle = "#bfdbfe";
      ctx.fillRect(bedX, bedTop - unit * 1.4, bedWidth, unit * 0.4);

      // —Å–ø–∏–Ω–∫–∞ –∫—Ä–æ–≤–∞—Ç–∏
      ctx.fillStyle = "#78350f";
      ctx.fillRect(bedX - unit * 0.8, bedTop - unit * 5, unit * 1.6, unit * 5);
    }

    function drawPixelCloud(cx, cy, size) {
      const unit = size / 8;
      const blocks = [
        { x: 0, y: 2, w: 8, h: 3 },
        { x: 1, y: 1, w: 6, h: 2 },
        { x: 2, y: 0, w: 4, h: 1 },
        { x: 2, y: 5, w: 4, h: 1 }
      ];
      blocks.forEach(b => {
        ctx.fillRect(
          cx + (b.x - 4) * unit,
          cy + (b.y - 3) * unit,
          b.w * unit,
          b.h * unit
        );
      });
    }

    // –ú–∏–ª–µ–µ, –¥–µ—Ç–∞–ª—å–Ω–µ–µ –æ–≤—Ü–∞ —Å –∫–æ—Ä–æ—Ç–∫–∏–º–∏ –ª–∞–ø–∫–∞–º–∏
    function drawSheep() {
      const s = state.sheep;
      const unit = s.size / 8;
      let offsetY = 0;

      if (state.jumpTime > 0) {
        const t = 1 - state.jumpTime / state.jumpDuration;
        offsetY = -Math.sin(t * Math.PI) * unit * 2.5;
      }

      const cx = s.x;
      const cy = s.y + offsetY;

      // —Ç–µ–Ω—å –Ω–∞ –∫—Ä–æ–≤–∞—Ç–∏
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.ellipse(cx, cy + unit * 3.5, unit * 3, unit * 1.3, 0, 0, Math.PI * 2);
      ctx.fillStyle = "#64748b";
      ctx.fill();
      ctx.restore();

      // —Ç–µ–ª–æ (–º–Ω–æ–≥–æ –ø–∏–∫—Å–µ–ª–µ–π, —á—Ç–æ–±—ã –ø—É—à–∏—Å—Ç–æ)
      ctx.fillStyle = "#f9fafb";
      ctx.fillRect(cx - unit * 3, cy - unit * 2, unit * 6, unit * 4);
      ctx.fillRect(cx - unit * 2.8, cy - unit * 2.6, unit * 5.6, unit * 1);
      ctx.fillRect(cx - unit * 2.5, cy + unit * 2, unit * 5, unit * 1);
      ctx.fillStyle = "#e5e7eb";
      ctx.fillRect(cx - unit * 3, cy - unit * 0.5, unit, unit * 1.8);
      ctx.fillRect(cx + unit * 2, cy - unit * 0.5, unit, unit * 1.8);

      // –≥–æ–ª–æ–≤–∞
      ctx.fillStyle = "#111827";
      ctx.fillRect(cx + unit * 2.6, cy - unit * 1.2, unit * 2, unit * 3);
      ctx.fillStyle = "#f9fafb";
      ctx.fillRect(cx + unit * 2.6, cy - unit * 0.6, unit * 1.2, unit * 1.8);

      // —É—à–∏
      ctx.fillStyle = "#111827";
      ctx.fillRect(cx + unit * 2.6, cy - unit * 1.6, unit * 0.8, unit * 0.8);
      ctx.fillRect(cx + unit * 3.8, cy - unit * 1.5, unit * 0.8, unit * 0.9);

      // –≥–ª–∞–∑–∞
      ctx.fillStyle = "#000000";
      ctx.fillRect(cx + unit * 2.9, cy - unit * 0.3, unit * 0.6, unit * 0.6);
      ctx.fillRect(cx + unit * 3.6, cy - unit * 0.3, unit * 0.6, unit * 0.6);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(cx + unit * 3, cy - unit * 0.3, unit * 0.3, unit * 0.3);
      ctx.fillRect(cx + unit * 3.7, cy - unit * 0.3, unit * 0.3, unit * 0.3);

      // —â—ë—á–∫–∏
      ctx.fillStyle = "#fecaca";
      ctx.fillRect(cx + unit * 2.7, cy + unit * 0.6, unit * 0.6, unit * 0.5);
      ctx.fillRect(cx + unit * 3.7, cy + unit * 0.6, unit * 0.6, unit * 0.5);

      // —É–∫–æ—Ä–æ—á–µ–Ω–Ω—ã–µ –Ω–æ–∂–∫–∏
      ctx.fillStyle = "#020617";
      const legH = unit * 1.5;
      ctx.fillRect(cx - unit * 2, cy + unit * 2, unit * 0.9, legH);
      ctx.fillRect(cx,       cy + unit * 2, unit * 0.9, legH);
      ctx.fillRect(cx + unit * 2, cy + unit * 2, unit * 0.9, legH);

      // —Ö–≤–æ—Å—Ç
      ctx.fillStyle = "#f9fafb";
      ctx.fillRect(cx - unit * 3.4, cy - unit * 0.4, unit * 0.8, unit * 1.2);
    }

    function step(timestamp) {
      if (!state.lastTs) state.lastTs = timestamp;
      const dt = timestamp - state.lastTs;
      state.lastTs = timestamp;

      state.wavePhase += dt;
      if (state.jumpTime > 0) {
        state.jumpTime -= dt;
        if (state.jumpTime < 0) state.jumpTime = 0;
      }

      updateZzz(dt);

      ctx.clearRect(0, 0, w, h);
      drawBackground();
      drawSheep();
      drawZzz();

      requestAnimationFrame(step);
    }

    // init
    resizeCanvas();
    updateScoreViews();
    requestAnimationFrame(step);
  </script>
</body>
</html>
