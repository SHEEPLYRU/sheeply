<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>SHEEPLY BALANCE</title>
  <style>
    :root{
      --bg:#070707;
      --border: rgba(255,255,255,.14);
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;overflow:hidden;background:var(--bg);color:var(--txt);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{height:100%;display:grid;place-items:center;padding:14px}
    .app{
      width:min(560px,100%); height:min(940px,100%);
      border-radius: clamp(18px, 3vw, 30px);
      background:
        radial-gradient(900px 520px at 25% 0%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(900px 520px at 90% 20%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      overflow:hidden;
      position:relative;
    }
    canvas{position:absolute; inset:0}
    #fx{z-index:1}
    #game{z-index:2}

    .hud{
      position:absolute; left:0; right:0; top:0; z-index:3;
      padding:14px 16px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      pointer-events:none;
    }
    .pill{
      pointer-events:auto;
      display:flex; gap:10px; align-items:center;
      padding:8px 10px; border-radius:999px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .mini{display:flex;flex-direction:column;gap:2px;min-width:70px}
    .mini .k{font-size:11px;color:var(--muted);letter-spacing:.35px}
    .mini .v{font-size:14px;font-weight:950;letter-spacing:.5px}
    .btn{
      pointer-events:auto;
      border:none;cursor:pointer;color:var(--txt);
      width:42px;height:42px;border-radius:14px;
      display:grid;place-items:center;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      transition: transform .08s ease, filter .15s ease;
      user-select:none;
    }
    .btn:active{transform: translateY(1px) scale(.99); filter:brightness(1.06);}

    .overlay{
      position:absolute; inset:0; z-index:4;
      display:grid; place-items:center; padding:18px;
      background: radial-gradient(900px 600px at 50% 25%, rgba(255,255,255,.10), rgba(0,0,0,.62) 70%),
                  rgba(0,0,0,.35);
      backdrop-filter: blur(12px);
    }
    .panel{
      width:min(420px,100%);
      border-radius: 26px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      padding:16px;
    }
    .row{display:flex;gap:10px}
    .wide{
      flex:1;height:48px;border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color:var(--txt);
      font-weight:950;
      letter-spacing:.9px;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 18px 50px rgba(0,0,0,.30);
    }
    .wide:active{transform: translateY(1px) scale(.99)}
    .tiny{
      margin-top:10px;
      font-size:11px;color:rgba(255,255,255,.55);
      display:flex;justify-content:space-between
    }
    .shake{animation: shake .18s linear 1}
    @keyframes shake{
      0%{transform:translateX(0)}25%{transform:translateX(-3px)}
      50%{transform:translateX(3px)}75%{transform:translateX(-2px)}
      100%{transform:translateX(0)}
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="app" id="app">
    <canvas id="fx"></canvas>
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="pill">
        <div class="mini"><div class="k">T</div><div class="v" id="t">0.0</div></div>
        <div class="mini"><div class="k">B</div><div class="v" id="b">0.0</div></div>
        <div class="mini"><div class="k">⚖</div><div class="v" id="a">0</div></div>
      </div>
      <div style="display:flex;gap:10px">
        <button class="btn" id="send" title="send">⤴</button>
        <button class="btn" id="pause" title="pause">⏸</button>
      </div>
    </div>

    <div class="overlay" id="ov">
      <div class="panel">
        <div class="row">
          <button class="wide" id="play">PLAY</button>
          <button class="wide" id="mode">HARD</button>
        </div>
        <div class="tiny">
          <span>hold = tilt</span>
          <span>SHEEPLY BALANCE</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const TG = window.Telegram?.WebApp;
  try{ TG?.ready(); TG?.expand(); }catch(e){}

  const el = {
    app: document.getElementById('app'),
    fx: document.getElementById('fx'),
    game: document.getElementById('game'),
    ov: document.getElementById('ov'),
    play: document.getElementById('play'),
    mode: document.getElementById('mode'),
    pause: document.getElementById('pause'),
    send: document.getElementById('send'),
    t: document.getElementById('t'),
    b: document.getElementById('b'),
    a: document.getElementById('a'),
  };

  // canvas
  const g = el.game.getContext('2d');
  const fx = el.fx.getContext('2d');
  let W=0,H=0,dpr=1;

  function resize(){
    const r = el.app.getBoundingClientRect();
    dpr = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(r.width*dpr);
    H = Math.floor(r.height*dpr);
    for(const c of [el.game, el.fx]){
      c.width=W; c.height=H;
      c.style.width=r.width+'px';
      c.style.height=r.height+'px';
    }
  }
  window.addEventListener('resize', resize, {passive:true}); resize();

  // particles
  const P=[];
  function burst(x,y,n=20,bright=true){
    for(let i=0;i<n;i++){
      const a=Math.random()*Math.PI*2;
      const sp=(Math.random()*2.4+1.0)*(bright?1.05:.95);
      P.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:1,r:(Math.random()*3+1),bright});
    }
  }

  // state
  const LS_BEST="sheeply_balance_best_v1";
  let best = +localStorage.getItem(LS_BEST) || 0;

  let running=false, paused=false, hard=true;
  let t0=0, time=0;

  // controls: hold and drag left/right to tilt, or tap left/right half for impulse
  let holding=false;
  let ptrX=0, ptrY=0;
  let lastDown=0;

  // plank (seesaw)
  const plank = {
    x:0, y:0, L:0,
    ang:0, angV:0,
    angTarget:0
  };

  // sheep (ball on plank)
  const sheep = {
    s:0,   // along plank (0 at center)
    v:0,   // along velocity
    r:0,
    alive:true
  };

  // difficulty params
  function params(){
    const base = Math.min(W,H);
    return {
      g: (hard ? 2600 : 2300) * dpr,
      tiltMax: (hard ? 0.62 : 0.52),         // radians
      tiltFollow: (hard ? 16 : 14),
      tiltDamp: (hard ? 0.92 : 0.93),
      plankDamp: (hard ? 0.985 : 0.988),
      sheepDamp: (hard ? 0.993 : 0.994),
      edgeSlack: (hard ? 0.86 : 0.90),
      plankL: Math.max(320*dpr, base*0.72),
      sheepR: Math.max(11*dpr, base*0.022),
    };
  }

  function reset(){
    running=false; paused=false;
    time=0;

    const p=params();
    plank.x = W*0.5;
    plank.y = H*0.62;
    plank.L = p.plankL;
    plank.ang = 0;
    plank.angV = 0;
    plank.angTarget = 0;

    sheep.s = 0;
    sheep.v = 0;
    sheep.r = p.sheepR;
    sheep.alive = true;

    holding=false;
    el.pause.textContent="⏸";
    updateHUD();
  }

  function start(){
    reset();
    running=true; paused=false;
    t0 = performance.now();
    el.ov.style.display="none";
    try{ TG?.HapticFeedback?.impactOccurred?.('light'); }catch(e){}
  }

  function end(){
    running=false; paused=false;
    const sec = time;
    if(sec > best) best = sec;
    localStorage.setItem(LS_BEST, best);

    send(false);
    el.ov.style.display="grid";
    el.play.textContent="PLAY";
  }

  function send(manual){
    const data = JSON.stringify({
      game:"sheeply_balance",
      time: +time.toFixed(2),
      best: +Math.max(best, time).toFixed(2),
      hard,
      ts: Date.now(),
      manual: !!manual
    });
    try{
      if(TG?.sendData){
        TG.sendData(data);
        TG?.HapticFeedback?.impactOccurred?.('light');
      }
    }catch(e){}
  }

  function updateHUD(){
    el.t.textContent = time.toFixed(1);
    el.b.textContent = best.toFixed(1);
    // tilt indicator (small)
    el.a.textContent = String(Math.round((plank.ang / (Math.PI/2))*100));
  }

  // input
  el.game.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    if(el.ov.style.display !== "none"){ start(); return; }
    holding=true;
    ptrX=e.clientX; ptrY=e.clientY;
    lastDown=performance.now();
    try{ el.game.setPointerCapture(e.pointerId); }catch(_){}

    // tap impulse: if quick press, nudge target based on side
    // (we’ll decide on pointerup using duration)
  }, {passive:false});

  el.game.addEventListener('pointermove', (e)=>{
    if(!holding) return;
    ptrX=e.clientX; ptrY=e.clientY;
  });

  el.game.addEventListener('pointerup', (e)=>{
    e.preventDefault();
    const dt = performance.now() - lastDown;
    // quick tap = impulse
    if(dt < 140 && running && !paused){
      const r = el.app.getBoundingClientRect();
      const x = e.clientX - r.left;
      const side = (x < r.width/2) ? -1 : 1;
      plank.angV += side * (hard ? 2.2 : 1.9);
      burst(plank.x + side*plank.L*0.15, plank.y, 16, true);
      try{ TG?.HapticFeedback?.impactOccurred?.('light'); }catch(_){}
    }
    holding=false;
    try{ el.game.releasePointerCapture(e.pointerId); }catch(_){}
  }, {passive:false});
  el.game.addEventListener('pointercancel', ()=>{holding=false;}, {passive:true});

  window.addEventListener('keydown', (e)=>{
    if(e.code==="ArrowLeft"){ plank.angV -= 1.8; }
    if(e.code==="ArrowRight"){ plank.angV += 1.8; }
    if(e.code==="Space"){
      e.preventDefault();
      if(el.ov.style.display !== "none") start();
      else { paused=!paused; el.pause.textContent=paused?"▶":"⏸"; }
    }
  });

  // buttons
  el.play.addEventListener('click', start);
  el.mode.addEventListener('click', ()=>{
    hard=!hard;
    el.mode.textContent = hard ? "HARD" : "SOFT";
  });
  el.pause.addEventListener('click', ()=>{
    if(!running) return;
    paused=!paused;
    el.pause.textContent = paused ? "▶" : "⏸";
  });
  el.send.addEventListener('click', ()=>send(true));

  // physics
  function step(dt){
    if(!running || paused) return;

    time = (performance.now()-t0)/1000;

    const p = params();

    // control target angle from hold-drag
    if(holding){
      const r = el.app.getBoundingClientRect();
      const x = (ptrX - r.left) / r.width;  // 0..1
      // map to -tiltMax..tiltMax
      plank.angTarget = (x*2 - 1) * p.tiltMax;
    } else {
      plank.angTarget *= 0.94;
    }

    // spring plank angle to target + damping
    const err = plank.angTarget - plank.ang;
    plank.angV += err * p.tiltFollow * dt;
    plank.angV *= Math.pow(p.plankDamp, dt*60);
    plank.ang += plank.angV * dt;

    // clamp tilt
    plank.ang = Math.max(-p.tiltMax, Math.min(p.tiltMax, plank.ang));

    // sheep dynamics on a tilted plank:
    // acceleration along plank = g * sin(angle) (downhill)
    const a = p.g * Math.sin(plank.ang);
    sheep.v += a * dt;

    // damping
    sheep.v *= Math.pow(p.sheepDamp, dt*60);

    // integrate position
    sheep.s += sheep.v * dt;

    // plank half-length minus safe margin
    const half = (plank.L*0.5) * p.edgeSlack;

    // friction boost near center to make it feel controllable
    const centerPull = -sheep.s * (hard ? 0.6 : 0.7);
    sheep.v += centerPull * dt;

    // fail if out of bounds
    if(Math.abs(sheep.s) > half){
      sheep.alive=false;
      burst(plank.x + Math.sign(sheep.s)*plank.L*0.48, plank.y, 42, false);
      el.app.classList.add('shake');
      setTimeout(()=>el.app.classList.remove('shake'),180);
      try{ TG?.HapticFeedback?.notificationOccurred?.('error'); }catch(e){}
      end();
      return;
    }

    // tiny “perfect balance” reward (stay near center)
    if(Math.abs(sheep.s) < plank.L*0.06 && Math.abs(plank.ang) < 0.06){
      // subtle sparkle
      if(Math.random()<0.05){
        burst(plank.x, plank.y - 20*dpr, 8, true);
      }
    }

    updateHUD();
  }

  // drawing helpers
  function roundRect(ctx, x,y,w,h,r, fill){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
    if(fill) ctx.fill(); else ctx.stroke();
  }

  function draw(){
    g.clearRect(0,0,W,H);
    g.fillStyle="rgba(0,0,0,1)";
    g.fillRect(0,0,W,H);

    // subtle grid
    g.globalAlpha=0.06;
    g.fillStyle="rgba(255,255,255,1)";
    const stepG = Math.floor(92*dpr);
    for(let x=0;x<W;x+=stepG) g.fillRect(x,0,1,H);
    g.globalAlpha=1;

    // pivot base
    g.save();
    g.translate(plank.x, plank.y);
    g.fillStyle="rgba(255,255,255,.10)";
    g.shadowBlur=22*dpr;
    g.shadowColor="rgba(255,255,255,.10)";
    roundRect(g, -34*dpr, 18*dpr, 68*dpr, 14*dpr, 10*dpr, true);
    g.shadowBlur=0;

    // plank
    g.rotate(plank.ang);
    g.fillStyle="rgba(255,255,255,.88)";
    g.shadowBlur=26*dpr;
    g.shadowColor="rgba(255,255,255,.14)";
    roundRect(g, -plank.L*0.5, 0, plank.L, 16*dpr, 12*dpr, true);
    g.shadowBlur=0;

    // edge marks (very minimal)
    g.globalAlpha=0.22;
    g.fillStyle="rgba(0,0,0,1)";
    roundRect(g, -plank.L*0.5 + 10*dpr, 3*dpr, 26*dpr, 10*dpr, 7*dpr, true);
    roundRect(g, plank.L*0.5 - 36*dpr, 3*dpr, 26*dpr, 10*dpr, 7*dpr, true);
    g.globalAlpha=1;

    // sheep (body + head) at s along plank
    const sx = sheep.s;
    const sy = -14*dpr;
    const r = sheep.r;

    g.save();
    g.translate(sx, sy);

    // body
    g.fillStyle="rgba(255,255,255,.92)";
    g.shadowBlur=18*dpr;
    g.shadowColor="rgba(255,255,255,.14)";
    g.beginPath();
    g.ellipse(0,0, r*1.25, r*1.0, 0, 0, Math.PI*2);
    g.fill();

    // head
    g.shadowBlur=0;
    g.fillStyle="rgba(0,0,0,.55)";
    g.beginPath();
    g.ellipse(r*0.95, r*0.10, r*0.55, r*0.45, 0, 0, Math.PI*2);
    g.fill();

    // eye
    g.fillStyle="rgba(255,255,255,.85)";
    g.beginPath();
    g.arc(r*1.10, r*0.00, r*0.10, 0, Math.PI*2);
    g.fill();
    g.restore();

    g.restore(); // pivot space

    // vignette
    g.save();
    const vg = g.createRadialGradient(W*0.5, H*0.45, Math.min(W,H)*0.18, W*0.5, H*0.45, Math.min(W,H)*0.95);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, "rgba(0,0,0,.60)");
    g.fillStyle=vg;
    g.fillRect(0,0,W,H);
    g.restore();

    // particles
    fx.clearRect(0,0,W,H);
    for(let i=P.length-1;i>=0;i--){
      const p=P[i];
      p.life -= 0.016*1.12;
      p.x += p.vx*2.2*dpr;
      p.y += p.vy*2.2*dpr;
      p.vx *= 0.985; p.vy *= 0.985; p.vy += 0.10;
      if(p.life<=0){P.splice(i,1); continue;}
      fx.globalAlpha = Math.max(0,p.life);
      fx.beginPath();
      fx.arc(p.x,p.y,p.r*dpr,0,Math.PI*2);
      fx.fillStyle = p.bright ? "rgba(255,255,255,.95)" : "rgba(255,255,255,.35)";
      fx.shadowBlur = 16*dpr;
      fx.shadowColor = p.bright ? "rgba(255,255,255,.20)" : "rgba(255,255,255,.12)";
      fx.fill();
      fx.shadowBlur=0;
    }

    requestAnimationFrame(draw);
  }

  // main loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    step(dt);
    requestAnimationFrame(loop);
  }

  // init
  el.b.textContent = best.toFixed(1);
  reset();
  el.ov.style.display="grid";
  requestAnimationFrame(draw);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
