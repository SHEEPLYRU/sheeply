<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>SHEEPLY WORLD</title>
  <style>
    :root{
      --bg:#070707;
      --panel: rgba(255,255,255,.06);
      --border: rgba(255,255,255,.14);
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --r: 22px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;overflow:hidden;background:var(--bg);color:var(--txt);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{height:100%;display:grid;place-items:center;padding:14px}
    .app{
      width:min(560px,100%); height:min(940px,100%);
      border-radius: clamp(18px, 3vw, 30px);
      background:
        radial-gradient(900px 520px at 25% 0%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(900px 520px at 90% 20%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      overflow:hidden;
      position:relative;
    }
    canvas{position:absolute;inset:0}
    #fx{z-index:1}
    #game{z-index:2}

    .hud{
      position:absolute; left:0; right:0; top:0; z-index:3;
      padding:14px 16px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      pointer-events:none;
    }
    .pill{
      pointer-events:auto;
      display:flex; gap:10px; align-items:center;
      padding:8px 10px; border-radius:999px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .mini{display:flex;flex-direction:column;gap:2px;min-width:74px}
    .mini .k{font-size:11px;color:var(--muted);letter-spacing:.35px}
    .mini .v{font-size:14px;font-weight:950;letter-spacing:.5px}
    .btn{
      pointer-events:auto;
      border:none;cursor:pointer;color:var(--txt);
      width:42px;height:42px;border-radius:14px;
      display:grid;place-items:center;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      transition: transform .08s ease, filter .15s ease;
      user-select:none;
    }
    .btn:active{transform: translateY(1px) scale(.99); filter:brightness(1.06);}

    .overlay{
      position:absolute; inset:0; z-index:4;
      display:grid; place-items:center; padding:18px;
      background: radial-gradient(900px 600px at 50% 25%, rgba(255,255,255,.10), rgba(0,0,0,.62) 70%),
                  rgba(0,0,0,.35);
      backdrop-filter: blur(12px);
    }
    .panel{
      width:min(420px,100%);
      border-radius: 26px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      padding:16px;
    }
    .row{display:flex;gap:10px}
    .wide{
      flex:1;height:48px;border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color:var(--txt);
      font-weight:950;
      letter-spacing:.9px;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 18px 50px rgba(0,0,0,.30);
    }
    .wide:active{transform: translateY(1px) scale(.99)}
    .tiny{
      margin-top:10px;
      font-size:11px;color:rgba(255,255,255,.55);
      display:flex;justify-content:space-between
    }
    .shake{animation: shake .18s linear 1}
    @keyframes shake{
      0%{transform:translateX(0)}25%{transform:translateX(-3px)}
      50%{transform:translateX(3px)}75%{transform:translateX(-2px)}
      100%{transform:translateX(0)}
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="app" id="app">
    <canvas id="fx"></canvas>
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="pill">
        <div class="mini"><div class="k">S</div><div class="v" id="s">0</div></div>
        <div class="mini"><div class="k">B</div><div class="v" id="b">0</div></div>
        <div class="mini"><div class="k">W</div><div class="v" id="w">⬜</div></div>
      </div>
      <div style="display:flex;gap:10px">
        <button class="btn" id="send" title="send">⤴</button>
        <button class="btn" id="pause" title="pause">⏸</button>
      </div>
    </div>

    <div class="overlay" id="ov">
      <div class="panel">
        <div class="row">
          <button class="wide" id="play">PLAY</button>
          <button class="wide" id="mode">HARD</button>
        </div>
        <div class="tiny">
          <span>tap = shift</span>
          <span>SHEEPLY WORLD</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // Telegram WebApp (works in browser)
  const TG = window.Telegram?.WebApp;
  try{ TG?.ready(); TG?.expand(); }catch(e){}

  const el = {
    app: document.getElementById('app'),
    fx: document.getElementById('fx'),
    game: document.getElementById('game'),
    ov: document.getElementById('ov'),
    play: document.getElementById('play'),
    mode: document.getElementById('mode'),
    pause: document.getElementById('pause'),
    send: document.getElementById('send'),
    s: document.getElementById('s'),
    b: document.getElementById('b'),
    w: document.getElementById('w'),
  };

  // ----- Canvas -----
  const g = el.game.getContext('2d');
  const fx = el.fx.getContext('2d');
  let W=0,H=0,dpr=1;

  function resize(){
    const r = el.app.getBoundingClientRect();
    dpr = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(r.width*dpr);
    H = Math.floor(r.height*dpr);
    for(const c of [el.game, el.fx]){
      c.width=W; c.height=H;
      c.style.width=r.width+'px';
      c.style.height=r.height+'px';
    }
  }
  window.addEventListener('resize', resize, {passive:true}); resize();

  // ----- FX particles (B/W) -----
  const P=[];
  function burst(x,y,n=18,bright=true){
    for(let i=0;i<n;i++){
      const a=Math.random()*Math.PI*2;
      const sp=(Math.random()*2.4+1.0)*(bright?1.05:.95);
      P.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:1,r:(Math.random()*3+1),bright});
    }
  }

  // ----- Game state -----
  const LS_BEST="sheeply_world_best_v1";
  let best = +localStorage.getItem(LS_BEST) || 0;

  let running=false, paused=false, hard=true;
  let world = 1; // 1 = white world (white platforms solid), -1 = black world

  // Player (sheep-ish)
  const player = { x:0, y:0, vx:0, vy:0, r:0, alive:true, onGround:false };
  let camX = 0;
  let score = 0;

  // Level blocks
  // type: 1 white, -1 black, 0 neutral (always solid) [we mainly use 1/-1]
  const blocks = [];
  let nextSpawnX = 0;

  // Difficulty
  function rand(a,b){return a+Math.random()*(b-a)}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

  function reset(){
    running=false; paused=false;
    world = 1;
    score = 0;
    camX = 0;

    player.x = W*0.28;
    player.y = H*0.46;
    player.vx = 0; player.vy = 0;
    player.r = Math.max(10*dpr, Math.min(W,H)*0.022);
    player.alive = true;
    player.onGround = false;

    blocks.length = 0;
    nextSpawnX = 0;

    // build initial runway
    const groundY = H*0.72;
    for(let i=0;i<12;i++){
      const w = rand(120, 220)*dpr;
      const gap = rand(34, 78)*dpr;
      const type = (Math.random()<0.55)? 1 : -1;
      pushBlock(nextSpawnX, groundY, w, 20*dpr, type);
      nextSpawnX += w + gap;
    }

    updateHUD();
  }

  function pushBlock(x, y, w, h, type){
    blocks.push({x,y,w,h,type});
  }

  function activeSolid(type){
    // neutral (0) always solid
    if(type===0) return true;
    return type === world;
  }

  function shift(){
    if(!running || paused) return;
    world *= -1;
    el.w.textContent = world===1 ? "⬜" : "⬛";

    const cx = player.x - camX;
    const cy = player.y;
    burst(cx, cy, 22, world===1);

    try{ TG?.HapticFeedback?.impactOccurred?.('light'); }catch(e){}
  }

  // Input: tap anywhere to shift
  el.game.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    if(el.ov.style.display !== "none"){ start(); return; }
    shift();
  }, {passive:false});
  window.addEventListener('keydown', (e)=>{
    if(e.code==="Space"){
      e.preventDefault();
      if(el.ov.style.display !== "none") start();
      else shift();
    }
  });

  // Buttons
  el.play.addEventListener('click', start);
  el.mode.addEventListener('click', ()=>{
    hard = !hard;
    el.mode.textContent = hard ? "HARD" : "SOFT";
  });
  el.pause.addEventListener('click', ()=>{
    if(!running) return;
    paused = !paused;
    el.pause.textContent = paused ? "▶" : "⏸";
  });
  el.send.addEventListener('click', ()=>send(true));

  function start(){
    reset();
    running=true; paused=false;
    el.ov.style.display="none";
    el.pause.textContent="⏸";
    try{ TG?.HapticFeedback?.impactOccurred?.('light'); }catch(e){}
  }

  function die(){
    if(!player.alive) return;
    player.alive=false;
    running=false; paused=false;

    best = Math.max(best, score);
    localStorage.setItem(LS_BEST, best);

    send(false);

    // overlay back
    el.ov.style.display="grid";
    el.play.textContent="PLAY";

    el.app.classList.add('shake');
    setTimeout(()=>el.app.classList.remove('shake'),180);

    try{ TG?.HapticFeedback?.notificationOccurred?.('error'); }catch(e){}
  }

  function send(manual){
    const data = JSON.stringify({
      game:"sheeply_world",
      score, best,
      hard,
      ts: Date.now(),
      manual: !!manual
    });
    try{
      if(TG?.sendData){
        TG.sendData(data);
        TG?.HapticFeedback?.impactOccurred?.('light');
      }
    }catch(e){}
  }

  function updateHUD(){
    el.s.textContent = String(score);
    el.b.textContent = String(best);
    el.w.textContent = world===1 ? "⬜" : "⬛";
  }

  // Physics helpers
  function aabb(px,py, pw,ph, bx,by, bw,bh){
    return px < bx+bw && px+pw > bx && py < by+bh && py+ph > by;
  }

  function step(dt){
    if(!running || paused) return;

    const speed = (hard ? 320 : 280) * dpr;
    const grav  = (hard ? 1800 : 1550) * dpr;
    const jumpV = (hard ? 620 : 580) * dpr;

    // auto-run
    player.vx = speed;

    // gravity
    player.vy += grav * dt;

    // move X
    let nx = player.x + player.vx*dt;
    let ny = player.y + player.vy*dt;
    player.onGround = false;

    // collision with active blocks (simple: resolve Y only for platforming feel)
    // We also make "inactive" blocks act as hazards if you touch them (nice SHIFT feel).
    const pw = player.r*2, ph = player.r*2;
    const px = nx - player.r, py = ny - player.r;

    // world bounds / floor death
    if(ny > H + 200*dpr) { die(); return; }

    // ensure we always have blocks ahead
    spawnAhead();

    // check collisions
    for(const b of blocks){
      const bx = b.x, by = b.y, bw=b.w, bh=b.h;

      // only consider nearby blocks
      if(bx + bw < camX - 200*dpr) continue;
      if(bx > camX + W + 400*dpr) continue;

      if(aabb(px,py,pw,ph, bx,by,bw,bh)){
        if(activeSolid(b.type)){
          // landing from above
          const prevY = (player.y - player.r);
          if(prevY + ph <= by + 6*dpr && player.vy > 0){
            ny = by - player.r;
            player.vy = 0;
            player.onGround = true;
          } else {
            // side hit / inside: small bounce, but keep moving
            player.vy *= -0.15;
          }
        } else {
          // touched inactive = glitch/hazard
          burst((player.x-camX), player.y, 18, false);
          die();
          return;
        }
      }
    }

    // auto-jump when grounded at platform edge (tiny assist so it feels good on tap-only)
    if(player.onGround){
      // look a bit ahead under feet
      const lookX = nx + player.r*1.4;
      const footY = ny + player.r + 6*dpr;
      let hasFloor = false;
      for(const b of blocks){
        if(!activeSolid(b.type)) continue;
        if(lookX >= b.x && lookX <= b.x+b.w && footY >= b.y && footY <= b.y+b.h){
          hasFloor = true; break;
        }
      }
      if(!hasFloor){
        player.vy = -jumpV;
        player.onGround = false;
        burst((player.x-camX), player.y, 10, true);
      }
    }

    player.x = nx;
    player.y = ny;

    // camera follows
    camX = player.x - W*0.30;

    // score = distance
    score = Math.max(score, Math.floor((player.x / (120*dpr))));
    updateHUD();
  }

  function spawnAhead(){
    const groundY = H*0.72;
    // keep generating until far enough
    while(nextSpawnX < camX + W*1.8){
      const w = rand(110, hard?210:240)*dpr;
      const gap = rand(hard?44:36, hard?92:78)*dpr;

      // sometimes elevated platform (requires SHIFT timing, still auto-jumps between solids)
      const elevChance = hard ? 0.22 : 0.16;
      const y = (Math.random()<elevChance) ? groundY - rand(70, 150)*dpr : groundY;
      const h = (y===groundY) ? 20*dpr : 18*dpr;

      // alternate blocks types more in hard mode
      const type = (Math.random() < (hard?0.50:0.56)) ? 1 : -1;

      pushBlock(nextSpawnX, y, w, h, type);

      // add occasional "bridge" of opposite type above (forces shift)
      if(hard && Math.random()<0.22){
        const opp = -type;
        pushBlock(nextSpawnX + w*0.22, y - rand(64, 110)*dpr, w*0.52, 16*dpr, opp);
      }

      nextSpawnX += w + gap;
    }

    // cleanup old
    while(blocks.length && blocks[0].x + blocks[0].w < camX - 600*dpr){
      blocks.shift();
    }
  }

  // ----- Render -----
  function draw(){
    // background
    g.clearRect(0,0,W,H);
    g.fillStyle = "rgba(0,0,0,1)";
    g.fillRect(0,0,W,H);

    // subtle parallax grid
    g.globalAlpha = 0.06;
    g.fillStyle = "rgba(255,255,255,1)";
    const step = Math.floor(90*dpr);
    const off = ((-camX*0.2) % step + step) % step;
    for(let x = -off; x < W; x += step) g.fillRect(x, 0, 1, H);
    g.globalAlpha = 1;

    // world tint: slight invert feel
    if(world===-1){
      g.globalAlpha = 0.10;
      g.fillStyle = "rgba(255,255,255,1)";
      g.fillRect(0,0,W,H);
      g.globalAlpha = 1;
    }

    // draw blocks
    for(const b of blocks){
      const x = b.x - camX;
      if(x > W+300*dpr || x + b.w < -300*dpr) continue;

      const solid = activeSolid(b.type);
      const isWhite = b.type===1;

      // active = bright, inactive = faint outline
      if(solid){
        g.fillStyle = isWhite ? "rgba(255,255,255,.92)" : "rgba(255,255,255,.22)";
        g.shadowBlur = 14*dpr;
        g.shadowColor = isWhite ? "rgba(255,255,255,.18)" : "rgba(255,255,255,.10)";
        roundRect(g, x, b.y, b.w, b.h, 10*dpr, true);
        g.shadowBlur = 0;
      } else {
        g.strokeStyle = "rgba(255,255,255,.18)";
        g.lineWidth = 2*dpr;
        roundRect(g, x, b.y, b.w, b.h, 10*dpr, false);
      }
    }

    // exit vibe (far right glow line)
    g.globalAlpha = 0.08;
    g.fillStyle = "rgba(255,255,255,1)";
    g.fillRect(W-3*dpr, 0, 3*dpr, H);
    g.globalAlpha = 1;

    // sheep (simple: body + head)
    const sx = player.x - camX;
    const sy = player.y;
    const r = player.r;

    // body
    g.save();
    g.translate(sx, sy);
    g.shadowBlur = 18*dpr;
    g.shadowColor = "rgba(255,255,255,.18)";
    g.fillStyle = "rgba(255,255,255,.90)";
    g.beginPath();
    g.ellipse(0, 0, r*1.25, r*1.0, 0, 0, Math.PI*2);
    g.fill();

    // head (slightly darker)
    g.shadowBlur = 0;
    g.fillStyle = "rgba(0,0,0,.55)";
    g.beginPath();
    g.ellipse(r*0.95, r*0.10, r*0.55, r*0.45, 0, 0, Math.PI*2);
    g.fill();

    // tiny eye (white dot)
    g.fillStyle = "rgba(255,255,255,.85)";
    g.beginPath();
    g.arc(r*1.10, r*0.00, r*0.10, 0, Math.PI*2);
    g.fill();
    g.restore();

    // vignette
    g.save();
    const vg = g.createRadialGradient(W*0.5, H*0.45, Math.min(W,H)*0.22, W*0.5, H*0.45, Math.min(W,H)*0.85);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, "rgba(0,0,0,.55)");
    g.fillStyle = vg;
    g.fillRect(0,0,W,H);
    g.restore();

    // FX particles
    fx.clearRect(0,0,W,H);
    for(let i=P.length-1;i>=0;i--){
      const p=P[i];
      p.life -= 0.016*1.10;
      p.x += p.vx*2.2*dpr;
      p.y += p.vy*2.2*dpr;
      p.vx *= 0.985; p.vy *= 0.985; p.vy += 0.10;
      if(p.life<=0){P.splice(i,1); continue;}
      fx.globalAlpha = Math.max(0,p.life);
      fx.beginPath();
      fx.arc(p.x,p.y,p.r*dpr,0,Math.PI*2);
      fx.fillStyle = p.bright ? "rgba(255,255,255,.95)" : "rgba(255,255,255,.35)";
      fx.shadowBlur = 16*dpr;
      fx.shadowColor = p.bright ? "rgba(255,255,255,.20)" : "rgba(255,255,255,.12)";
      fx.fill();
      fx.shadowBlur=0;
    }

    requestAnimationFrame(draw);
  }

  function roundRect(ctx, x,y,w,h,r, fill){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
    if(fill) ctx.fill(); else ctx.stroke();
  }

  // ----- Main loop -----
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    step(dt);
    requestAnimationFrame(loop);
  }

  // init
  el.b.textContent = String(best);
  reset();
  el.ov.style.display="grid";
  requestAnimationFrame(draw);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
