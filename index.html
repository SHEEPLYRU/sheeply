<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>SHEEPLY 3D Clicker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * { box-sizing: border-box; margin:0; padding:0; }
    body {
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background: radial-gradient(circle at top, #0f172a, #020617);
      overflow:hidden;
      color:#f9fafb;
    }
    #gameWrapper {
      position:relative;
      width:100vw;
      height:100vh;
      overflow:hidden;
    }
    #hud {
      position:absolute;
      top:10px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(15,23,42,0.85);
      padding:8px 16px;
      border-radius:999px;
      font-size:14px;
      display:flex;
      gap:10px;
      align-items:center;
      box-shadow:0 12px 30px rgba(0,0,0,0.6);
      backdrop-filter:blur(16px);
      z-index:5;
    }
    #hud span strong { font-weight:700; }
    #hint {
      position:absolute;
      bottom:12px;
      left:50%;
      transform:translateX(-50%);
      font-size:12px;
      background:rgba(15,23,42,0.75);
      padding:6px 14px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,0.6);
      z-index:5;
    }
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="gameWrapper">
    <div id="hud">
      <span>üêë –û–≤—Ü—ã: <strong id="score">0</strong></span>
      <span>‚úã –ó–∞ —Ç–∞–ø: <strong id="perClick">1</strong></span>
    </div>
    <div id="hint">–ö—Ä—É—Ç–∏ —Å—Ü–µ–Ω—É –∏ —Ç–∞–ø–∞–π –ø–æ –æ–≤—Ü–µ, —á—Ç–æ–±—ã —Å–æ–±—Ä–∞—Ç—å —Å—Ç–∞–¥–æ</div>
  </div>

  <!-- Three.js —Å CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    const wrapper = document.getElementById('gameWrapper');
    const scoreEl = document.getElementById('score');
    const perClickEl = document.getElementById('perClick');
    const hintEl = document.getElementById('hint');

    let score = 0;
    let perClick = 1;

    // --- –±–∞–∑–æ–≤–∞—è —Å—Ü–µ–Ω–∞ ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(0, 2.2, 4);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    wrapper.appendChild(renderer.domElement);

    // —Å–≤–µ—Ç
    const hemi = new THREE.HemisphereLight(0xffffff, 0x3b6b2a, 0.9);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(4, 6, 3);
    dir.castShadow = true;
    scene.add(dir);

    renderer.shadowMap.enabled = true;

    // –∑–µ–º–ª—è
    const groundGeo = new THREE.PlaneGeometry(20, 20);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x51b94b });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- 3D –æ–≤—Ü–∞ (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è, –Ω–æ –º–∏–ª–µ–Ω—å–∫–∞—è) ---
    const sheep = new THREE.Group();

    // —Ç–µ–ª–æ
    const bodyGeo = new THREE.SphereGeometry(0.8, 32, 32);
    const bodyMat = new THREE.MeshStandardMaterial({
      color: 0xfafafa,
      roughness: 0.7,
      metalness: 0.1
    });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.castShadow = true;
    sheep.add(body);

    // –≥–æ–ª–æ–≤–∞
    const headGeo = new THREE.SphereGeometry(0.35, 32, 32);
    const headMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.set(0, 0.25, 0.8);
    head.castShadow = true;
    sheep.add(head);

    // —É—à–∫–∏
    const earGeo = new THREE.SphereGeometry(0.16, 16, 16);
    const earL = new THREE.Mesh(earGeo, headMat);
    const earR = new THREE.Mesh(earGeo, headMat);
    earL.position.set(-0.3, 0.25, 0.65);
    earR.position.set(0.3, 0.25, 0.65);
    sheep.add(earL, earR);

    // –º–æ—Ä–¥–æ—á–∫–∞ (—Å–≤–µ—Ç–ª—ã–π –∫—Ä—É–∂–æ–∫)
    const noseGeo = new THREE.SphereGeometry(0.2, 16, 16);
    const noseMat = new THREE.MeshStandardMaterial({ color: 0xf5f5f5 });
    const nose = new THREE.Mesh(noseGeo, noseMat);
    nose.position.set(0, 0.1, 1.0);
    sheep.add(nose);

    // –≥–ª–∞–∑–∫–∏
    const eyeGeo = new THREE.SphereGeometry(0.07, 16, 16);
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
    const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
    const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
    eyeL.position.set(-0.13, 0.25, 0.95);
    eyeR.position.set(0.13, 0.25, 0.95);
    sheep.add(eyeL, eyeR);

    // –Ω–æ–∂–∫–∏
    const legGeo = new THREE.CylinderGeometry(0.11, 0.12, 0.6, 16);
    const legMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
    const legPositions = [
      [-0.4, -0.6, 0.4],
      [0.4, -0.6, 0.4],
      [-0.4, -0.6, -0.4],
      [0.4, -0.6, -0.4]
    ];
    legPositions.forEach(p => {
      const leg = new THREE.Mesh(legGeo, legMat);
      leg.position.set(p[0], p[1], p[2]);
      leg.castShadow = true;
      sheep.add(leg);
    });

    sheep.position.y = 1;
    scene.add(sheep);

    // --- OrbitControls ---
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 0.8, 0);

    // --- –∫–ª–∏–∫ –ø–æ –æ–≤—Ü–µ ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onPointerDown(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ( (event.clientX || event.touches[0].clientX) - rect.left ) / rect.width;
      const y = ( (event.clientY || event.touches[0].clientY) - rect.top ) / rect.height;

      mouse.x = x * 2 - 1;
      mouse.y = - (y * 2 - 1);

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(sheep, true);

      if (intersects.length > 0) {
        // –∫–ª–∏–∫ –ø–æ –æ–≤—Ü–µ
        score += perClick;
        scoreEl.textContent = score;
        hintEl.style.display = 'none';
        // –∞–Ω–∏–º–∞—Ü–∏—è –ø–æ–¥–ø—Ä—ã–≥–∏–≤–∞–Ω–∏—è
        jumpStart = performance.now();
      }
    }

    renderer.domElement.addEventListener('mousedown', onPointerDown);
    renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: true });

    // –ø—Ä–æ—Å—Ç–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –ø—Ä—ã–∂–∫–∞
    let jumpStart = null;

    function animate(time) {
      requestAnimationFrame(animate);

      const t = time * 0.001;

      // –ª—ë–≥–∫–æ–µ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ –æ–≤—Ü—ã
      sheep.position.y = 1 + Math.sin(t * 2) * 0.03;

      // –ø–æ–¥–ø—Ä—ã–≥–∏–≤–∞–Ω–∏–µ –ø—Ä–∏ –∫–ª–∏–∫–µ
      if (jumpStart !== null) {
        const p = Math.min((time - jumpStart) / 250, 1); // 0..1
        const offset = Math.sin(p * Math.PI) * 0.35;
        sheep.position.y += offset;
        if (p >= 1) jumpStart = null;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    animate(0);

    // –∞–¥–∞–ø—Ç–∞—Ü–∏—è –∫ —ç–∫—Ä–∞–Ω—É
    function onResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
  </script>
</body>
</html>
