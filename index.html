<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–õ–æ–≤–∏ —Ç–µ—Ö–Ω–∏–∫—É –≤ –∫–æ—Ä–∑–∏–Ω—É</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1f2937, #020617);
      color: #f9fafb;
      overflow: hidden;
    }

    #gameWrapper {
      position: relative;
      width: 100%;
      height: 100vh;
      overflow: hidden;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top, #111827, #020617);
      touch-action: none; /* –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ touchmove */
    }

    /* HUD (–æ—á–∫–∏, –∂–∏–∑–Ω–∏) */
    #hud {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      padding: 6px 14px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(10px);
      font-size: 14px;
      align-items: center;
      z-index: 5;
      pointer-events: none;
    }

    #hud span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    /* –û–≤–µ—Ä–ª–µ–∏ (—Å—Ç–∞—Ä—Ç, –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã) */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 1));
    }

    .overlay-inner {
      width: 90%;
      max-width: 420px;
      padding: 20px 18px;
      border-radius: 22px;
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(30, 64, 175, 0.4));
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.6);
      text-align: center;
    }

    .overlay h1,
    .overlay h2 {
      margin: 0 0 12px;
      font-weight: 700;
    }

    .overlay p {
      margin: 0 0 18px;
      font-size: 14px;
      line-height: 1.4;
      color: #e5e7eb;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 22px;
      border-radius: 999px;
      border: none;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #f9fafb;
      box-shadow: 0 10px 25px rgba(22, 163, 74, 0.6);
      transition: transform 0.1s ease, box-shadow 0.1s ease;
    }

    .btn:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 4px 12px rgba(22, 163, 74, 0.7);
    }

    .btn-secondary {
      background: rgba(15, 23, 42, 0.8);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .hint {
      font-size: 12px;
      color: #9ca3af;
      margin-top: 8px;
    }

    .stats {
      font-size: 14px;
      margin-top: 6px;
      color: #e5e7eb;
    }

    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div id="gameWrapper">
    <canvas id="gameCanvas"></canvas>

    <div id="hud">
      <span>‚≠ê –û—á–∫–∏: <strong id="scoreValue">0</strong></span>
      <span>‚ù§Ô∏è –ñ–∏–∑–Ω–∏: <strong id="livesValue">3</strong></span>
    </div>

    <!-- –°—Ç–∞—Ä—Ç–æ–≤—ã–π —ç–∫—Ä–∞–Ω -->
    <div id="startScreen" class="overlay">
      <div class="overlay-inner">
        <h1>–õ–æ–≤–∏ —Ç–µ—Ö–Ω–∏–∫—É</h1>
        <p>
          –£–ø—Ä–∞–≤–ª—è–π –∫–æ—Ä–∑–∏–Ω–æ–π –∏ –ª–æ–≤–∏—Ç–µ –ø–∞–¥–∞—é—â–∏–µ –≥–∞–¥–∂–µ—Ç—ã (üì± üíª üñ•).
          –ù–µ –¥–∞–π –∏–º —É–ø–∞—Å—Ç—å –º–∏–º–æ ‚Äî —É —Ç–µ–±—è –≤—Å–µ–≥–æ 3 –∂–∏–∑–Ω–∏!
        </p>
        <button class="btn" id="startBtn">–ò–≥—Ä–∞—Ç—å</button>
        <div class="hint">–î–≤–∏–≥–∞–π –ø–∞–ª—å—Ü–µ–º –ø–æ —ç–∫—Ä–∞–Ω—É, —á—Ç–æ–±—ã –¥–≤–∏–≥–∞—Ç—å –∫–æ—Ä–∑–∏–Ω—É</div>
      </div>
    </div>

    <!-- –≠–∫—Ä–∞–Ω –æ–∫–æ–Ω—á–∞–Ω–∏—è –∏–≥—Ä—ã -->
    <div id="gameOverScreen" class="overlay hidden">
      <div class="overlay-inner">
        <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</h2>
        <p class="stats">–¢–≤–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: <span id="finalScore">0</span> –æ—á–∫–æ–≤</p>
        <button class="btn" id="restartBtn">–ò–≥—Ä–∞—Ç—å –µ—â—ë —Ä–∞–∑</button>
        <div class="hint">–ü–æ–ø—Ä–æ–±—É–π –ø–æ–±–∏—Ç—å —Å–≤–æ–π —Ä–µ–∫–æ—Ä–¥!</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('scoreValue');
    const livesEl = document.getElementById('livesValue');
    const finalScoreEl = document.getElementById('finalScore');

    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');

    let gameWidth = 0;
    let gameHeight = 0;

    const basket = {
      x: 0,
      y: 0,
      width: 90,
      height: 18,
      radius: 10
    };

    const devices = [];
    const deviceEmojis = ['üì±', 'üíª', 'üñ•', '‚åöÔ∏è', 'üéß'];

    let score = 0;
    let lives = 3;
    let isRunning = false;
    let isGameOver = false;
    let lastTime = 0;
    let spawnTimer = 0;
    let spawnInterval = 900; // –º—Å –º–µ–∂–¥—É –ø–æ—è–≤–ª–µ–Ω–∏–µ–º –¥–µ–≤–∞–π—Å–æ–≤

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const oldWidth = gameWidth || rect.width;
      const oldHeight = gameHeight || rect.height;

      gameWidth = rect.width;
      gameHeight = rect.height;

      // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–æ—Ä–∑–∏–Ω—ã –ø—Ä–∏ —Ä–µ—Å–∞–π–∑–µ
      if (oldWidth !== gameWidth) {
        const ratioX = gameWidth / oldWidth;
        basket.x *= ratioX;
      }
      basket.y = gameHeight - 70;
    }

    function resetGame() {
      score = 0;
      lives = 3;
      spawnTimer = 0;
      devices.length = 0;
      isGameOver = false;

      scoreEl.textContent = score;
      livesEl.textContent = lives;

      // –Ω–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –∫–æ—Ä–∑–∏–Ω—ã
      basket.width = Math.max(80, gameWidth * 0.22);
      basket.height = 18;
      basket.x = gameWidth / 2 - basket.width / 2;
      basket.y = gameHeight - 70;
    }

    function spawnDevice() {
      const size = 30 + Math.random() * 12;
      const x = size / 2 + Math.random() * (gameWidth - size);
      const speed = 2.1 + Math.random() * 1.7; // –±–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –ø–∞–¥–µ–Ω–∏—è

      const emoji = deviceEmojis[Math.floor(Math.random() * deviceEmojis.length)];

      devices.push({
        x,
        y: -size,
        size,
        speed,
        emoji
      });
    }

    function update(delta) {
      if (!isRunning || isGameOver) return;

      const dt = delta; // –º—Å
      spawnTimer += dt;

      if (spawnTimer >= spawnInterval) {
        spawnDevice();
        spawnTimer = 0;
        // —Å–ª–µ–≥–∫–∞ —É—Å–∫–æ—Ä—è–µ–º –∏–≥—Ä—É —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
        if (spawnInterval > 400) {
          spawnInterval -= 5;
        }
      }

      // –æ–±–Ω–æ–≤–ª—è–µ–º –ø–∞–¥–µ–Ω–∏–µ –¥–µ–≤–∞–π—Å–æ–≤
      for (let i = devices.length - 1; i >= 0; i--) {
        const d = devices[i];
        d.y += d.speed * (dt / 16); // –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–æ–¥ 60fps

        // –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ø–∞–¥–∞–Ω–∏–µ –≤ –∫–æ—Ä–∑–∏–Ω—É
        const bottomY = d.y + d.size;
        const inYRange = bottomY >= basket.y && d.y <= basket.y + basket.height;
        const inXRange =
          d.x + d.size / 2 >= basket.x &&
          d.x - d.size / 2 <= basket.x + basket.width;

        if (inYRange && inXRange) {
          // –ø–æ–π–º–∞–ª–∏
          devices.splice(i, 1);
          score += 1;
          scoreEl.textContent = score;
          continue;
        }

        // —É–ø–∞–ª –Ω–∏–∂–µ —ç–∫—Ä–∞–Ω–∞
        if (d.y - d.size > gameHeight) {
          devices.splice(i, 1);
          lives -= 1;
          livesEl.textContent = lives;
          if (lives <= 0) {
            endGame();
            return;
          }
        }
      }
    }

    function drawBasket() {
      const { x, y, width, height, radius } = basket;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height);
      ctx.lineTo(x, y + height);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();

      const gradient = ctx.createLinearGradient(x, y, x, y + height);
      gradient.addColorStop(0, '#38bdf8');
      gradient.addColorStop(1, '#0ea5e9');
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(15, 23, 42, 0.9)';
      ctx.stroke();

      // –Ω–µ–±–æ–ª—å—à–∞—è —Ç–µ–Ω—å
      ctx.shadowColor = 'rgba(8, 47, 73, 0.7)';
      ctx.shadowBlur = 10;
      ctx.restore();
    }

    function drawDevices() {
      ctx.font = '26px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      devices.forEach(d => {
        ctx.save();
        ctx.translate(d.x, d.y);
        ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
        ctx.shadowBlur = 8;
        ctx.fillText(d.emoji, 0, 0);
        ctx.restore();
      });
    }

    function drawBackgroundGlow() {
      // –ª—ë–≥–∫–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ –≤–Ω–∏–∑—É, –∏–º–∏—Ç–∏—Ä—É–µ–º –ø–ª–æ—â–∞–¥–∫—É
      const gradient = ctx.createRadialGradient(
        gameWidth / 2,
        gameHeight,
        10,
        gameWidth / 2,
        gameHeight,
        gameWidth / 1.2
      );
      gradient.addColorStop(0, 'rgba(56, 189, 248, 0.25)');
      gradient.addColorStop(1, 'rgba(15, 23, 42, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, gameWidth, gameHeight);
    }

    function draw() {
      ctx.clearRect(0, 0, gameWidth, gameHeight);
      drawBackgroundGlow();
      drawBasket();
      drawDevices();
    }

    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const delta = timestamp - lastTime;
      lastTime = timestamp;

      if (isRunning && !isGameOver) {
        update(delta);
        draw();
      } else {
        // –≤—Å—ë —Ä–∞–≤–Ω–æ –ø–µ—Ä–µ—Ä–∏—Å—É–µ–º —Å—Ç–∞—Ç–∏—á–Ω—É—é —Å—Ü–µ–Ω—É
        draw();
      }

      requestAnimationFrame(gameLoop);
    }

    function moveBasketTo(clientX) {
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const half = basket.width / 2;
      basket.x = Math.max(0, Math.min(gameWidth - basket.width, x - half));
    }

    function endGame() {
      isGameOver = true;
      isRunning = false;
      finalScoreEl.textContent = score;
      gameOverScreen.classList.remove('hidden');
    }

    // –°–æ–±—ã—Ç–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    canvas.addEventListener('mousemove', (e) => {
      moveBasketTo(e.clientX);
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (e.touches && e.touches.length > 0) {
        moveBasketTo(e.touches[0].clientX);
      }
    }, { passive: false });

    startBtn.addEventListener('click', () => {
      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      resetGame();
      isRunning = true;
      lastTime = performance.now();
    });

    restartBtn.addEventListener('click', () => {
      gameOverScreen.classList.add('hidden');
      resetGame();
      isRunning = true;
      lastTime = performance.now();
    });

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    window.addEventListener('resize', () => {
      resizeCanvas();
    });

    resizeCanvas();
    resetGame();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
