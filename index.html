<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>SHEEPLY WORLD</title>
  <style>
    :root{
      --bg:#070707;
      --border: rgba(255,255,255,.14);
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;overflow:hidden;background:var(--bg);color:var(--txt);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{height:100%;display:grid;place-items:center;padding:14px}
    .app{
      width:min(560px,100%); height:min(940px,100%);
      border-radius: clamp(18px, 3vw, 30px);
      background:
        radial-gradient(900px 520px at 25% 0%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(900px 520px at 90% 20%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      overflow:hidden;
      position:relative;
    }
    canvas{position:absolute;inset:0}
    #fx{z-index:1}
    #game{z-index:2}

    .hud{
      position:absolute; left:0; right:0; top:0; z-index:3;
      padding:14px 16px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      pointer-events:none;
    }
    .pill{
      pointer-events:auto;
      display:flex; gap:10px; align-items:center;
      padding:8px 10px; border-radius:999px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .mini{display:flex;flex-direction:column;gap:2px;min-width:66px}
    .mini .k{font-size:11px;color:var(--muted);letter-spacing:.35px}
    .mini .v{font-size:14px;font-weight:950;letter-spacing:.5px}
    .btn{
      pointer-events:auto;
      border:none;cursor:pointer;color:var(--txt);
      width:42px;height:42px;border-radius:14px;
      display:grid;place-items:center;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      transition: transform .08s ease, filter .15s ease;
      user-select:none;
    }
    .btn:active{transform: translateY(1px) scale(.99); filter:brightness(1.06);}

    .overlay{
      position:absolute; inset:0; z-index:4;
      display:grid; place-items:center; padding:18px;
      background: radial-gradient(900px 600px at 50% 25%, rgba(255,255,255,.10), rgba(0,0,0,.62) 70%),
                  rgba(0,0,0,.35);
      backdrop-filter: blur(12px);
    }
    .panel{
      width:min(420px,100%);
      border-radius: 26px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      padding:16px;
    }
    .row{display:flex;gap:10px}
    .wide{
      flex:1;height:48px;border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color:var(--txt);
      font-weight:950;
      letter-spacing:.9px;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 18px 50px rgba(0,0,0,.30);
    }
    .wide:active{transform: translateY(1px) scale(.99)}
    .tiny{
      margin-top:10px;
      font-size:11px;color:rgba(255,255,255,.55);
      display:flex;justify-content:space-between
    }
    .shake{animation: shake .18s linear 1}
    @keyframes shake{
      0%{transform:translateX(0)}25%{transform:translateX(-3px)}
      50%{transform:translateX(3px)}75%{transform:translateX(-2px)}
      100%{transform:translateX(0)}
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="app" id="app">
    <canvas id="fx"></canvas>
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="pill">
        <div class="mini"><div class="k">S</div><div class="v" id="s">0</div></div>
        <div class="mini"><div class="k">B</div><div class="v" id="b">0</div></div>
        <div class="mini"><div class="k">C</div><div class="v" id="c">0</div></div>
        <div class="mini"><div class="k">X</div><div class="v" id="x">0</div></div>
        <div class="mini"><div class="k">W</div><div class="v" id="w">⬜</div></div>
      </div>
      <div style="display:flex;gap:10px">
        <button class="btn" id="send" title="send">⤴</button>
        <button class="btn" id="pause" title="pause">⏸</button>
      </div>
    </div>

    <div class="overlay" id="ov">
      <div class="panel">
        <div class="row">
          <button class="wide" id="play">PLAY</button>
          <button class="wide" id="mode">HARD</button>
        </div>
        <div class="tiny">
          <span>hold = move • tap = shift</span>
          <span>SHEEPLY WORLD</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const TG = window.Telegram?.WebApp;
  try{ TG?.ready(); TG?.expand(); }catch(e){}

  const el = {
    app: document.getElementById('app'),
    fx: document.getElementById('fx'),
    game: document.getElementById('game'),
    ov: document.getElementById('ov'),
    play: document.getElementById('play'),
    mode: document.getElementById('mode'),
    pause: document.getElementById('pause'),
    send: document.getElementById('send'),
    s: document.getElementById('s'),
    b: document.getElementById('b'),
    c: document.getElementById('c'),
    x: document.getElementById('x'),
    w: document.getElementById('w'),
  };

  // ----- Canvas -----
  const g = el.game.getContext('2d');
  const fx = el.fx.getContext('2d');
  let W=0,H=0,dpr=1;

  function resize(){
    const r = el.app.getBoundingClientRect();
    dpr = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(r.width*dpr);
    H = Math.floor(r.height*dpr);
    for(const c of [el.game, el.fx]){
      c.width=W; c.height=H;
      c.style.width=r.width+'px';
      c.style.height=r.height+'px';
    }
  }
  window.addEventListener('resize', resize, {passive:true}); resize();

  // ----- FX particles (B/W) -----
  const P=[];
  function burst(x,y,n=18,bright=true){
    for(let i=0;i<n;i++){
      const a=Math.random()*Math.PI*2;
      const sp=(Math.random()*2.4+1.0)*(bright?1.05:.95);
      P.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:1,r:(Math.random()*3+1),bright});
    }
  }

  // ----- Game state -----
  const LS_BEST="sheeply_world_best_v2";
  let best = +localStorage.getItem(LS_BEST) || 0;

  let running=false, paused=false, hard=true;
  let world = 1; // 1 = white world solid, -1 = black world solid

  // Player (sheep-ish)
  const player = { x:0, y:0, vx:0, vy:0, r:0, alive:true, onGround:false };
  let camX = 0;
  let score = 0;

  // Ideal timing
  let combo = 0;
  let comboMax = 0;
  let lastShiftAt = -1;
  let lastShiftWorld = 1;
  let perfectFlash = 0;

  // Movement input: HOLD = move, TAP = shift
  let holdMove = false;
  let downAt = 0;

  // Level
  const blocks = [];        // {x,y,w,h,type}
  const checkpoints = [];   // {id,x,y,active}
  let nextSpawnX = 0;

  // Respawn data
  let cpId = 0;
  let cpX = 0;
  let cpY = 0;
  let cpWorld = 1;
  let cpScore = 0;

  function rand(a,b){return a+Math.random()*(b-a)}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

  function activeSolid(type){
    if(type===0) return true;       // neutral always solid
    return type === world;
  }

  function updateHUD(){
    el.s.textContent = String(score);
    el.b.textContent = String(best);
    el.c.textContent = String(cpId);
    el.x.textContent = String(combo);
    el.w.textContent = world===1 ? "⬜" : "⬛";
  }

  function pushBlock(x, y, w, h, type){
    blocks.push({x,y,w,h,type});
  }

  function pushCheckpoint(x, y){
    const id = checkpoints.length + 1;
    checkpoints.push({id, x, y, active:false});
  }

  function setCheckpoint(id, x, y){
    cpId = id;
    cpX = x;
    cpY = y;
    cpWorld = world;
    cpScore = score;
    updateHUD();
    const sx = player.x - camX;
    burst(sx, player.y, 26, true);
    try{ TG?.HapticFeedback?.notificationOccurred?.('success'); }catch(e){}
  }

  function reset(){
    running=false; paused=false;
    world = 1;
    score = 0;
    combo = 0; comboMax = 0;
    lastShiftAt = -1;
    perfectFlash = 0;

    camX = 0;
    holdMove = false;

    player.r = Math.max(10*dpr, Math.min(W,H)*0.022);
    player.x = W*0.28;
    player.y = H*0.46;
    player.vx = 0; player.vy = 0;
    player.alive = true;
    player.onGround = false;

    blocks.length = 0;
    checkpoints.length = 0;
    nextSpawnX = 0;

    // initial checkpoint at start
    cpId = 0;
    cpX = player.x;
    cpY = player.y;
    cpWorld = world;
    cpScore = 0;

    // build initial runway + early checkpoint
    const groundY = H*0.72;
    for(let i=0;i<14;i++){
      const w = rand(120, 240)*dpr;
      const gap = rand(38, 84)*dpr;
      const type = (Math.random()<0.55)? 1 : -1;
      pushBlock(nextSpawnX, groundY, w, 20*dpr, type);
      // place a checkpoint every ~5 platforms
      if(i===4) pushCheckpoint(nextSpawnX + w*0.72, groundY - 36*dpr);
      nextSpawnX += w + gap;
    }

    updateHUD();
  }

  function shift(){
    if(!running || paused) return;
    world *= -1;
    el.w.textContent = world===1 ? "⬜" : "⬛";
    lastShiftAt = performance.now();
    lastShiftWorld = world;

    const cx = player.x - camX;
    burst(cx, player.y, 22, world===1);
    try{ TG?.HapticFeedback?.impactOccurred?.('light'); }catch(e){}
  }

  function start(){
    reset();
    running=true; paused=false;
    el.ov.style.display="none";
    el.pause.textContent="⏸";
    try{ TG?.HapticFeedback?.impactOccurred?.('light'); }catch(e){}
  }

  function respawn(){
    // back to last checkpoint (sheep does NOT move unless you hold)
    world = cpWorld;
    score = cpScore;
    combo = 0;

    player.x = cpX;
    player.y = cpY;
    player.vx = 0; player.vy = 0;
    player.onGround = false;

    camX = player.x - W*0.30;

    perfectFlash = 0.7;
    burst(player.x - camX, player.y, 28, true);
    updateHUD();
  }

  function die(){
    if(!player.alive) return;
    player.alive=false;

    el.app.classList.add('shake');
    setTimeout(()=>el.app.classList.remove('shake'),180);
    try{ TG?.HapticFeedback?.notificationOccurred?.('error'); }catch(e){}

    // if no checkpoint yet, show overlay; otherwise respawn
    if(cpId === 0){
      running=false; paused=false;
      best = Math.max(best, score);
      localStorage.setItem(LS_BEST, best);
      send(false);
      el.ov.style.display="grid";
      el.play.textContent="PLAY";
      return;
    }

    // checkpoint mode: instant respawn
    player.alive=true;
    respawn();
  }

  function endRun(){
    running=false; paused=false;
    best = Math.max(best, score);
    localStorage.setItem(LS_BEST, best);
    send(false);
    el.ov.style.display="grid";
    el.play.textContent="PLAY";
  }

  function send(manual){
    const data = JSON.stringify({
      game:"sheeply_world",
      score, best: Math.max(best, score),
      checkpoint: cpId,
      comboMax,
      hard,
      ts: Date.now(),
      manual: !!manual
    });
    try{
      if(TG?.sendData){
        TG.sendData(data);
        TG?.HapticFeedback?.impactOccurred?.('light');
      }
    }catch(e){}
  }

  // ---- Controls: HOLD to move, TAP to shift ----
  el.game.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    if(el.ov.style.display !== "none"){ start(); return; }
    downAt = performance.now();
    holdMove = true;
    try{ el.game.setPointerCapture(e.pointerId); }catch(_){}
  }, {passive:false});

  el.game.addEventListener('pointerup', (e)=>{
    e.preventDefault();
    holdMove = false;
    const dt = performance.now() - downAt;
    // short press => shift
    if(dt < 170) shift();
    try{ el.game.releasePointerCapture(e.pointerId); }catch(_){}
  }, {passive:false});

  el.game.addEventListener('pointercancel', ()=>{ holdMove=false; }, {passive:true});

  window.addEventListener('keydown', (e)=>{
    if(e.code==="Space"){
      e.preventDefault();
      if(el.ov.style.display !== "none") start();
      else shift();
    }
  });

  // Buttons
  el.play.addEventListener('click', start);
  el.mode.addEventListener('click', ()=>{
    hard = !hard;
    el.mode.textContent = hard ? "HARD" : "SOFT";
  });
  el.pause.addEventListener('click', ()=>{
    if(!running) return;
    paused = !paused;
    el.pause.textContent = paused ? "▶" : "⏸";
  });
  el.send.addEventListener('click', ()=>send(true));

  // ---- Physics helpers ----
  function aabb(px,py, pw,ph, bx,by, bw,bh){
    return px < bx+bw && px+pw > bx && py < by+bh && py+ph > by;
  }

  function spawnAhead(){
    const groundY = H*0.72;
    while(nextSpawnX < camX + W*2.1){
      const w = rand(120, hard?220:250)*dpr;
      const gap = rand(hard?44:36, hard?92:78)*dpr;

      const elevChance = hard ? 0.22 : 0.16;
      const y = (Math.random()<elevChance) ? groundY - rand(70, 150)*dpr : groundY;
      const h = (y===groundY) ? 20*dpr : 18*dpr;

      // more alternation = more shifting
      const type = (Math.random() < (hard?0.50:0.56)) ? 1 : -1;

      pushBlock(nextSpawnX, y, w, h, type);

      // occasional opposite bridge above (forces shift)
      if(hard && Math.random()<0.22){
        const opp = -type;
        pushBlock(nextSpawnX + w*0.22, y - rand(64, 110)*dpr, w*0.52, 16*dpr, opp);
      }

      // checkpoints every ~900..1200px
      if(checkpoints.length < 18 && (checkpoints.length===0 || (nextSpawnX - checkpoints[checkpoints.length-1].x) > rand(900,1200)*dpr)){
        pushCheckpoint(nextSpawnX + w*0.70, y - 36*dpr);
      }

      nextSpawnX += w + gap;
    }

    // cleanup
    while(blocks.length && blocks[0].x + blocks[0].w < camX - 700*dpr) blocks.shift();
  }

  // ---- Perfect timing ----
  // If you SHIFT shortly before landing on a platform that requires the new world,
  // you get PERFECT: score boost + combo++.
  function maybePerfectOnLanding(landedBlockType){
    const now = performance.now();
    const windowMs = hard ? 170 : 200;
    if(lastShiftAt < 0) return false;

    const dt = now - lastShiftAt;
    const usedShift = (dt <= windowMs);
    const requiresThisWorld = (landedBlockType !== 0) && (landedBlockType === world);

    // only count if the world actually changed recently
    const changed = (world === lastShiftWorld);

    if(usedShift && requiresThisWorld && changed){
      combo++;
      comboMax = Math.max(comboMax, combo);
      const bonus = 12 + Math.min(6, combo)*4;
      score += bonus;
      perfectFlash = 1.0;
      burst(player.x - camX, player.y, 30, true);
      try{ TG?.HapticFeedback?.impactOccurred?.('medium'); }catch(e){}
      return true;
    }
    return false;
  }

  function step(dt){
    if(!running || paused) return;

    spawnAhead();

    // movement: sheep only moves while HOLD (so it "doesn't fall by itself")
    const speed = (hard ? 320 : 280) * dpr;
    player.vx = holdMove ? speed : 0;

    const grav  = (hard ? 1850 : 1600) * dpr;
    const jumpV = (hard ? 610 : 570) * dpr;

    // gravity always, but if you're not moving you typically stay safely on platform
    player.vy += grav * dt;

    let nx = player.x + player.vx*dt;
    let ny = player.y + player.vy*dt;
    player.onGround = false;

    const pw = player.r*2, ph = player.r*2;
    const px = nx - player.r, py = ny - player.r;

    // death if fall far
    if(ny > H + 240*dpr){ die(); return; }

    // collisions
    for(const b of blocks){
      const bx=b.x, by=b.y, bw=b.w, bh=b.h;
      if(bx + bw < camX - 200*dpr) continue;
      if(bx > camX + W + 400*dpr) continue;

      if(aabb(px,py,pw,ph, bx,by,bw,bh)){
        if(activeSolid(b.type)){
          // landing from above
          const prevBottom = (player.y + player.r);
          if(prevBottom <= by + 6*dpr && player.vy > 0){
            ny = by - player.r;
            player.vy = 0;
            player.onGround = true;

            // PERFECT timing check
            maybePerfectOnLanding(b.type);
          } else {
            // side/inside: tiny bounce
            player.vy *= -0.15;
          }
        } else {
          // touching inactive is fatal
          burst((player.x-camX), player.y, 18, false);
          combo = 0;
          die();
          return;
        }
      }
    }

    // auto jump assist ONLY when moving (so standing still never "auto-falls")
    if(player.onGround && holdMove){
      const lookX = nx + player.r*1.4;
      const footY = ny + player.r + 6*dpr;
      let hasFloor = false;
      for(const b of blocks){
        if(!activeSolid(b.type)) continue;
        if(lookX >= b.x && lookX <= b.x+b.w && footY >= b.y && footY <= b.y+b.h){
          hasFloor = true; break;
        }
      }
      if(!hasFloor){
        player.vy = -jumpV;
        player.onGround = false;
        // (no points for auto jump)
      }
    }

    player.x = nx;
    player.y = ny;

    // camera
    camX = player.x - W*0.30;

    // score = distance progress (but only while moving)
    if(holdMove){
      score = Math.max(score, Math.floor((player.x / (120*dpr))));
    }

    // checkpoints pickup (neutral “flag”)
    for(const cp of checkpoints){
      if(cp.active) continue;
      const dx = player.x - cp.x;
      const dy = player.y - cp.y;
      if(Math.hypot(dx,dy) < 34*dpr){
        cp.active = true;
        setCheckpoint(cp.id, cp.x, cp.y - 18*dpr);
      }
    }

    // fade perfect flash
    perfectFlash = Math.max(0, perfectFlash - dt*1.6);

    // combo decay if you stop moving too long (keeps it “timing-based”)
    if(!holdMove && combo>0){
      combo = Math.max(0, combo - dt*0.8);
      combo = Math.floor(combo);
    }

    // update best live
    best = Math.max(best, score);
    localStorage.setItem(LS_BEST, best);

    updateHUD();
  }

  // ----- Render -----
  function roundRect(ctx, x,y,w,h,r, fill){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
    if(fill) ctx.fill(); else ctx.stroke();
  }

  function draw(){
    g.clearRect(0,0,W,H);
    g.fillStyle = "rgba(0,0,0,1)";
    g.fillRect(0,0,W,H);

    // subtle parallax grid
    g.globalAlpha = 0.06;
    g.fillStyle = "rgba(255,255,255,1)";
    const stepG = Math.floor(90*dpr);
    const off = ((-camX*0.2) % stepG + stepG) % stepG;
    for(let x = -off; x < W; x += stepG) g.fillRect(x, 0, 1, H);
    g.globalAlpha = 1;

    // world tint
    if(world===-1){
      g.globalAlpha = 0.10;
      g.fillStyle = "rgba(255,255,255,1)";
      g.fillRect(0,0,W,H);
      g.globalAlpha = 1;
    }

    // blocks
    for(const b of blocks){
      const x = b.x - camX;
      if(x > W+300*dpr || x + b.w < -300*dpr) continue;

      const solid = activeSolid(b.type);
      const isWhite = b.type===1;

      if(solid){
        g.fillStyle = isWhite ? "rgba(255,255,255,.92)" : "rgba(255,255,255,.22)";
        g.shadowBlur = 14*dpr;
        g.shadowColor = isWhite ? "rgba(255,255,255,.18)" : "rgba(255,255,255,.10)";
        roundRect(g, x, b.y, b.w, b.h, 10*dpr, true);
        g.shadowBlur = 0;
      } else {
        g.strokeStyle = "rgba(255,255,255,.18)";
        g.lineWidth = 2*dpr;
        roundRect(g, x, b.y, b.w, b.h, 10*dpr, false);
      }
    }

    // checkpoints (neutral flags)
    for(const cp of checkpoints){
      const x = cp.x - camX;
      if(x < -120*dpr || x > W+120*dpr) continue;
      const y = cp.y;

      g.save();
      g.globalAlpha = cp.active ? 0.90 : 0.35;
      g.strokeStyle = "rgba(255,255,255,.55)";
      g.lineWidth = 2*dpr;

      // pole
      g.beginPath();
      g.moveTo(x, y);
      g.lineTo(x, y + 34*dpr);
      g.stroke();

      // flag
      g.fillStyle = "rgba(255,255,255,.75)";
      g.beginPath();
      g.moveTo(x, y);
      g.lineTo(x + 16*dpr, y + 6*dpr);
      g.lineTo(x, y + 12*dpr);
      g.closePath();
      g.fill();

      // dot
      g.globalAlpha = cp.active ? 0.80 : 0.20;
      g.beginPath();
      g.arc(x, y+40*dpr, 3.2*dpr, 0, Math.PI*2);
      g.fillStyle="rgba(255,255,255,1)";
      g.fill();
      g.restore();
    }

    // sheep
    const sx = player.x - camX;
    const sy = player.y;
    const r = player.r;

    g.save();
    g.translate(sx, sy);
    g.shadowBlur = 18*dpr;
    g.shadowColor = "rgba(255,255,255,.18)";
    g.fillStyle = "rgba(255,255,255,.90)";
    g.beginPath();
    g.ellipse(0, 0, r*1.25, r*1.0, 0, 0, Math.PI*2);
    g.fill();

    g.shadowBlur = 0;
    g.fillStyle = "rgba(0,0,0,.55)";
    g.beginPath();
    g.ellipse(r*0.95, r*0.10, r*0.55, r*0.45, 0, 0, Math.PI*2);
    g.fill();

    g.fillStyle = "rgba(255,255,255,.85)";
    g.beginPath();
    g.arc(r*1.10, r*0.00, r*0.10, 0, Math.PI*2);
    g.fill();
    g.restore();

    // perfect flash (minimal feedback)
    if(perfectFlash > 0){
      g.save();
      g.globalAlpha = 0.14 * perfectFlash;
      g.fillStyle = "rgba(255,255,255,1)";
      g.fillRect(0,0,W,H);
      g.restore();
    }

    // vignette
    g.save();
    const vg = g.createRadialGradient(W*0.5, H*0.45, Math.min(W,H)*0.22, W*0.5, H*0.45, Math.min(W,H)*0.85);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, "rgba(0,0,0,.55)");
    g.fillStyle = vg;
    g.fillRect(0,0,W,H);
    g.restore();

    // FX particles
    fx.clearRect(0,0,W,H);
    for(let i=P.length-1;i>=0;i--){
      const p=P[i];
      p.life -= 0.016*1.10;
      p.x += p.vx*2.2*dpr;
      p.y += p.vy*2.2*dpr;
      p.vx *= 0.985; p.vy *= 0.985; p.vy += 0.10;
      if(p.life<=0){P.splice(i,1); continue;}
      fx.globalAlpha = Math.max(0,p.life);
      fx.beginPath();
      fx.arc(p.x,p.y,p.r*dpr,0,Math.PI*2);
      fx.fillStyle = p.bright ? "rgba(255,255,255,.95)" : "rgba(255,255,255,.35)";
      fx.shadowBlur = 16*dpr;
      fx.shadowColor = p.bright ? "rgba(255,255,255,.20)" : "rgba(255,255,255,.12)";
      fx.fill();
      fx.shadowBlur=0;
    }

    requestAnimationFrame(draw);
  }

  // ----- Main loop -----
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    step(dt);
    requestAnimationFrame(loop);
  }

  // init
  el.b.textContent = String(best);
  el.pause.textContent="⏸";
  reset();
  el.ov.style.display="grid";
  requestAnimationFrame(draw);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
