<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>DARK ROOM — NOIR</title>
  <style>
    :root{
      --bg:#070707;
      --panel: rgba(255,255,255,.06);
      --border: rgba(255,255,255,.14);
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --r: 22px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;overflow:hidden;background:var(--bg);color:var(--txt);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{height:100%;display:grid;place-items:center;padding:14px}
    .app{
      width:min(560px,100%); height:min(940px,100%);
      border-radius: clamp(18px, 3vw, 30px);
      background:
        radial-gradient(900px 520px at 25% 0%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(900px 520px at 90% 20%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      overflow:hidden;
      position:relative;
    }
    canvas{position:absolute; inset:0}
    #fx{z-index:1}
    #game{z-index:2}
    .hud{
      position:absolute; left:0; right:0; top:0; z-index:3;
      padding:14px 16px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      pointer-events:none;
    }
    .pill{
      pointer-events:auto;
      display:flex; gap:10px; align-items:center;
      padding:8px 10px; border-radius:999px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .mini{display:flex;flex-direction:column;gap:2px;min-width:74px}
    .mini .k{font-size:11px;color:var(--muted)}
    .mini .v{font-size:14px;font-weight:950;letter-spacing:.4px}
    .btn{
      pointer-events:auto;
      border:none;cursor:pointer;color:var(--txt);
      width:42px;height:42px;border-radius:14px;
      display:grid;place-items:center;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      transition: transform .08s ease, filter .15s ease;
      user-select:none;
    }
    .btn:active{transform: translateY(1px) scale(.99); filter:brightness(1.06);}

    /* subtle grain */
    .grain{
      position:absolute; inset:0; z-index:2; pointer-events:none; opacity:.12; mix-blend-mode:overlay;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='.5'/%3E%3C/svg%3E");
    }

    .overlay{
      position:absolute; inset:0; z-index:4;
      display:grid; place-items:center; padding:18px;
      background: radial-gradient(900px 600px at 50% 25%, rgba(255,255,255,.10), rgba(0,0,0,.62) 70%),
                  rgba(0,0,0,.35);
      backdrop-filter: blur(12px);
    }
    .panel{
      width:min(420px,100%);
      border-radius: 26px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      padding:16px;
    }
    .row{display:flex;gap:10px}
    .wide{
      flex:1;height:48px;border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color:var(--txt);
      font-weight:950;
      letter-spacing:.6px;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 18px 50px rgba(0,0,0,.30);
    }
    .wide:active{transform: translateY(1px) scale(.99)}
    .tiny{
      margin-top:10px;
      font-size:11px;color:rgba(255,255,255,.55);
      display:flex;justify-content:space-between
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="app" id="app">
    <canvas id="fx"></canvas>
    <canvas id="game"></canvas>
    <div class="grain"></div>

    <div class="hud">
      <div class="pill">
        <div class="mini"><div class="k">⏱</div><div class="v" id="t">0.0</div></div>
        <div class="mini"><div class="k">★</div><div class="v" id="b">0</div></div>
      </div>
      <div style="display:flex;gap:10px">
        <button class="btn" id="send" title="send">⤴</button>
        <button class="btn" id="reset" title="reset">↻</button>
      </div>
    </div>

    <div class="overlay" id="ov">
      <div class="panel">
        <div class="row">
          <button class="wide" id="play">PLAY</button>
          <button class="wide" id="mode">HARD</button>
        </div>
        <div class="tiny">
          <span>drag</span>
          <span>noir</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const TG = window.Telegram?.WebApp;
  try{ TG?.ready(); TG?.expand(); }catch(e){}

  const el = {
    app: document.getElementById('app'),
    fx: document.getElementById('fx'),
    game: document.getElementById('game'),
    ov: document.getElementById('ov'),
    play: document.getElementById('play'),
    mode: document.getElementById('mode'),
    send: document.getElementById('send'),
    reset: document.getElementById('reset'),
    t: document.getElementById('t'),
    b: document.getElementById('b'),
  };

  const g = el.game.getContext('2d');
  const fx = el.fx.getContext('2d');
  let W=0,H=0,dpr=1;
  function resize(){
    const r = el.app.getBoundingClientRect();
    dpr = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(r.width*dpr);
    H = Math.floor(r.height*dpr);
    for(const c of [el.game, el.fx]){
      c.width=W; c.height=H;
      c.style.width=r.width+'px';
      c.style.height=r.height+'px';
    }
  }
  window.addEventListener('resize', resize, {passive:true}); resize();

  // --- particles (white only) ---
  const P=[];
  function burst(x,y,n=20){
    for(let i=0;i<n;i++){
      const a=Math.random()*Math.PI*2;
      const sp=(Math.random()*2.4+1.0);
      P.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:1,r:(Math.random()*3+1)});
    }
  }

  // --- game settings ---
  let hard=true;
  const LS_BEST="dark_room_best_v1";
  let best=+localStorage.getItem(LS_BEST)||0;
  el.b.textContent = String(best);

  // Grid maze (0 empty, 1 wall)
  let grid=[], cols=0, rows=0, cs=0;
  let player={x:0,y:0, r:0};
  let exit={x:0,y:0};
  let running=false, t0=0, time=0;

  // Fog / light radius
  let lightBase=0;

  // Input: drag to steer (like a magnet)
  let pointerDown=false;
  let pointer={x:0,y:0};
  let vel={x:0,y:0};

  function rand(a,b){ return a + Math.random()*(b-a); }

  function buildMaze(){
    // cell size
    cs = Math.floor(Math.min(W,H) / (hard ? 18 : 16));
    cs = Math.max(cs, 22*dpr);
    cols = Math.floor(W / cs);
    rows = Math.floor(H / cs);

    // keep some padding for HUD
    const topPadCells = Math.ceil((74*dpr)/cs);
    const usableRows = rows - topPadCells;

    // init full walls
    grid = Array(cols*rows).fill(1);
    const idx = (x,y)=>y*cols+x;
    const inb = (x,y)=>x>=0&&y>=topPadCells&&x<cols&&y<rows;

    // randomized DFS maze on odd cells
    const startX = (Math.floor(rand(1, cols-2))|1);
    const startY = ((Math.floor(rand(topPadCells+1, rows-2))|1));
    const stack=[[startX,startY]];
    grid[idx(startX,startY)] = 0;

    const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
    while(stack.length){
      const [cx,cy]=stack[stack.length-1];
      // shuffle
      for(let i=dirs.length-1;i>0;i--){
        const j=(Math.random()*(i+1))|0;
        [dirs[i],dirs[j]]=[dirs[j],dirs[i]];
      }
      let moved=false;
      for(const [dx,dy] of dirs){
        const nx=cx+dx, ny=cy+dy;
        if(inb(nx,ny) && grid[idx(nx,ny)]===1){
          // carve
          grid[idx(cx+dx/2, cy+dy/2)] = 0;
          grid[idx(nx,ny)] = 0;
          stack.push([nx,ny]);
          moved=true;
          break;
        }
      }
      if(!moved) stack.pop();
    }

    // choose player start and exit far apart
    function randomEmpty(){
      for(let k=0;k<4000;k++){
        const x = (Math.random()*cols)|0;
        const y = (Math.random()*(usableRows))|0 + topPadCells;
        if(grid[idx(x,y)]===0) return {x,y};
      }
      return {x:startX,y:startY};
    }
    const a = randomEmpty();
    let b = randomEmpty();
    const dist = (p,q)=>Math.hypot(p.x-q.x,p.y-q.y);
    for(let k=0;k<30;k++){
      const c = randomEmpty();
      if(dist(a,c) > dist(a,b)) b=c;
    }

    player.x = (a.x+0.5)*cs;
    player.y = (a.y+0.5)*cs;
    player.r = Math.max(8*dpr, cs*0.18);

    exit.x = (b.x+0.5)*cs;
    exit.y = (b.y+0.5)*cs;

    lightBase = hard ? cs*2.15 : cs*2.7;

    vel.x=0; vel.y=0;
  }

  function isWallAt(px,py){
    const x = Math.floor(px/cs);
    const y = Math.floor(py/cs);
    if(x<0||y<0||x>=cols||y>=rows) return true;
    return grid[y*cols+x]===1;
  }

  function circleCollides(nx, ny){
    // sample a few points around the circle
    const r = player.r;
    const pts = [
      [nx+r, ny],[nx-r, ny],[nx, ny+r],[nx, ny-r],
      [nx+r*0.7, ny+r*0.7],[nx-r*0.7, ny+r*0.7],[nx+r*0.7, ny-r*0.7],[nx-r*0.7, ny-r*0.7],
    ];
    for(const [x,y] of pts){
      if(isWallAt(x,y)) return true;
    }
    return false;
  }

  function start(){
    buildMaze();
    running=true;
    t0 = performance.now();
    time = 0;
    el.ov.style.display="none";
    try{ TG?.HapticFeedback?.impactOccurred?.('light'); }catch(e){}
  }

  function end(){
    running=false;
    const final = time;
    best = (best===0) ? final : Math.min(best, final); // best = minimal time
    localStorage.setItem(LS_BEST, String(best));
    el.b.textContent = String(best.toFixed(1));
    send(false);

    el.ov.style.display="grid";
    el.play.textContent="PLAY";
  }

  function send(manual){
    const data = JSON.stringify({
      game:"dark_room",
      time: +time.toFixed(2),
      best: best ? +best.toFixed(2) : 0,
      hard,
      manual: !!manual,
      ts: Date.now()
    });
    try{
      if(TG?.sendData){
        TG.sendData(data);
        TG?.HapticFeedback?.impactOccurred?.('light');
      }
    }catch(e){}
  }

  // --- Input (drag to guide) ---
  el.game.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    if(el.ov.style.display!=="none"){ start(); return; }
    pointerDown=true;
    pointer.x = e.clientX; pointer.y = e.clientY;
    try{ el.game.setPointerCapture(e.pointerId); }catch(_){}
  }, {passive:false});
  el.game.addEventListener('pointermove', (e)=>{
    if(!pointerDown) return;
    pointer.x = e.clientX; pointer.y = e.clientY;
  });
  el.game.addEventListener('pointerup', (e)=>{
    pointerDown=false;
    try{ el.game.releasePointerCapture(e.pointerId); }catch(_){}
  });

  el.play.addEventListener('click', start);
  el.mode.addEventListener('click', ()=>{
    hard=!hard;
    el.mode.textContent = hard ? "HARD" : "SOFT";
  });
  el.send.addEventListener('click', ()=>send(true));
  el.reset.addEventListener('click', ()=>{
    el.ov.style.display="grid";
    el.play.textContent="PLAY";
    running=false;
    buildMaze();
  });

  window.addEventListener('keydown', (e)=>{
    if(e.code==="Space"){ e.preventDefault(); (el.ov.style.display!=="none") ? start() : (el.ov.style.display="grid", running=false); }
  });

  // --- Main loop ---
  let last = performance.now();
  function step(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    // update particles
    fx.clearRect(0,0,W,H);
    for(let i=P.length-1;i>=0;i--){
      const p=P[i];
      p.life -= dt*1.45;
      p.x += p.vx*60*dt;
      p.y += p.vy*60*dt;
      p.vx *= 0.985; p.vy *= 0.985; p.vy += 0.10;
      if(p.life<=0){P.splice(i,1); continue;}
      fx.globalAlpha = Math.max(0,p.life);
      fx.beginPath();
      fx.arc(p.x,p.y,p.r*dpr,0,Math.PI*2);
      fx.fillStyle = "rgba(255,255,255,.95)";
      fx.shadowBlur = 14*dpr;
      fx.shadowColor = "rgba(255,255,255,.18)";
      fx.fill();
      fx.shadowBlur = 0;
    }

    if(running){
      time = (now - t0)/1000;
      el.t.textContent = time.toFixed(1);

      // steering toward pointer (if pressed)
      let ax=0, ay=0;
      if(pointerDown){
        const ra = el.app.getBoundingClientRect();
        const tx = (pointer.x - ra.left) * dpr;
        const ty = (pointer.y - ra.top) * dpr;
        const dx = tx - player.x;
        const dy = ty - player.y;
        const d = Math.hypot(dx,dy) + 1e-6;
        const strength = hard ? 1100 : 920;
        ax = (dx/d) * strength;
        ay = (dy/d) * strength;
      }

      // integrate velocity
      vel.x += ax * dt;
      vel.y += ay * dt;

      // friction & max speed
      const fr = hard ? 0.78 : 0.82;
      vel.x *= Math.pow(fr, dt*60);
      vel.y *= Math.pow(fr, dt*60);
      const vmax = (hard ? 520 : 440) * dpr;
      const sp = Math.hypot(vel.x, vel.y);
      if(sp > vmax){
        vel.x = vel.x/sp * vmax;
        vel.y = vel.y/sp * vmax;
      }

      // try move with collision
      let nx = player.x + vel.x*dt;
      let ny = player.y + vel.y*dt;

      if(circleCollides(nx, player.y)){
        vel.x *= -0.25;
        nx = player.x;
      }
      if(circleCollides(player.x, ny)){
        vel.y *= -0.25;
        ny = player.y;
      }
      if(circleCollides(nx, ny)){
        vel.x *= -0.20;
        vel.y *= -0.20;
        nx = player.x; ny = player.y;
      }

      player.x = nx; player.y = ny;

      // win check
      const dExit = Math.hypot(player.x-exit.x, player.y-exit.y);
      if(dExit < cs*0.42){
        burst(exit.x, exit.y, 56);
        try{ TG?.HapticFeedback?.notificationOccurred?.('success'); }catch(e){}
        end();
      }
    }

    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  function draw(){
    g.clearRect(0,0,W,H);

    // background
    g.fillStyle = "rgba(0,0,0,1)";
    g.fillRect(0,0,W,H);

    // draw maze (very subtle)
    const wallA = hard ? 0.11 : 0.09;
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const v = grid[y*cols+x];
        if(v===1){
          g.fillStyle = `rgba(255,255,255,${wallA})`;
          g.fillRect(x*cs, y*cs, cs, cs);
        }
      }
    }

    // exit marker (almost invisible until you find it)
    g.save();
    g.translate(exit.x, exit.y);
    g.globalAlpha = 0.85;
    g.beginPath();
    g.arc(0,0, cs*0.18, 0, Math.PI*2);
    g.fillStyle = "rgba(255,255,255,.75)";
    g.shadowBlur = 18*dpr;
    g.shadowColor = "rgba(255,255,255,.18)";
    g.fill();
    g.restore();

    // player
    g.save();
    g.translate(player.x, player.y);
    g.beginPath();
    g.arc(0,0, player.r, 0, Math.PI*2);
    g.fillStyle = "rgba(255,255,255,.92)";
    g.shadowBlur =

