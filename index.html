<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>NOIR PULSE</title>
  <style>
    :root{
      --bg:#070707;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.09);
      --border: rgba(255,255,255,.14);
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --r: 22px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;overflow:hidden;background:var(--bg);color:var(--txt);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{height:100%;display:grid;place-items:center;padding:14px}
    .app{
      width:min(560px,100%); height:min(940px,100%);
      border-radius: clamp(18px, 3vw, 30px);
      background:
        radial-gradient(900px 520px at 20% 0%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(900px 520px at 90% 20%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      overflow:hidden;
      position:relative;
    }
    canvas#fx{position:absolute;inset:0;z-index:1}
    canvas#game{position:absolute;inset:0;z-index:2}
    .hud{
      position:absolute; left:0; right:0; top:0;
      z-index:3;
      padding:14px 16px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      pointer-events:none;
    }
    .pill{
      pointer-events:auto;
      display:flex;gap:10px;align-items:center;
      padding:8px 10px;border-radius:999px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .mini{display:flex;flex-direction:column;gap:2px;min-width:72px}
    .mini .k{font-size:11px;color:var(--muted)}
    .mini .v{font-size:14px;font-weight:950;letter-spacing:.4px}
    .btn{
      pointer-events:auto;
      border:none;cursor:pointer;color:var(--txt);
      width:42px;height:42px;border-radius:14px;
      display:grid;place-items:center;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      transition: transform .08s ease, filter .15s ease;
      user-select:none;
    }
    .btn:active{transform: translateY(1px) scale(.99); filter:brightness(1.06);}
    .overlay{
      position:absolute; inset:0; z-index:4;
      display:grid; place-items:center; padding:18px;
      background: radial-gradient(900px 600px at 50% 25%, rgba(255,255,255,.10), rgba(0,0,0,.55) 70%),
                  rgba(0,0,0,.35);
      backdrop-filter: blur(12px);
    }
    .panel{
      width:min(420px,100%);
      border-radius: 26px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      padding:16px;
    }
    .row{display:flex;gap:10px}
    .wide{
      flex:1;
      height:48px;border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color:var(--txt);
      font-weight:950;
      letter-spacing:.6px;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 18px 50px rgba(0,0,0,.30);
    }
    .wide:active{transform: translateY(1px) scale(.99)}
    .tiny{
      margin-top:10px;
      font-size:11px;color:rgba(255,255,255,.55);
      display:flex;justify-content:space-between
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="app" id="app">
    <canvas id="fx"></canvas>
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="pill">
        <div class="mini">
          <div class="k">S</div>
          <div class="v" id="s">0</div>
        </div>
        <div class="mini">
          <div class="k">B</div>
          <div class="v" id="b">0</div>
        </div>
        <div class="mini">
          <div class="k">T</div>
          <div class="v"><span id="t">30.0</span></div>
        </div>
      </div>

      <div style="display:flex;gap:10px">
        <button class="btn" id="send" title="send">⤴</button>
        <button class="btn" id="pause" title="pause">⏸</button>
      </div>
    </div>

    <div class="overlay" id="ov">
      <div class="panel">
        <div class="row">
          <button class="wide" id="play">PLAY</button>
          <button class="wide" id="mode">HARD</button>
        </div>
        <div class="tiny">
          <span>tap • hold</span>
          <span>noir</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // Telegram WebApp (works in browser too)
  const TG = window.Telegram?.WebApp;
  try{ TG?.ready(); TG?.expand(); }catch(e){}

  const el = {
    app: document.getElementById('app'),
    fx: document.getElementById('fx'),
    game: document.getElementById('game'),
    ov: document.getElementById('ov'),
    play: document.getElementById('play'),
    mode: document.getElementById('mode'),
    pause: document.getElementById('pause'),
    send: document.getElementById('send'),
    s: document.getElementById('s'),
    b: document.getElementById('b'),
    t: document.getElementById('t'),
  };

  // ----- Canvas sizing -----
  const g = el.game.getContext('2d');
  const fx = el.fx.getContext('2d');
  let W=0,H=0,dpr=1;

  function resize(){
    const r = el.app.getBoundingClientRect();
    dpr = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(r.width * dpr);
    H = Math.floor(r.height * dpr);
    for(const c of [el.game, el.fx]){
      c.width = W; c.height = H;
      c.style.width = r.width+'px';
      c.style.height = r.height+'px';
    }
  }
  window.addEventListener('resize', resize, {passive:true}); resize();

  // ----- Particles (B/W) -----
  const P=[];
  function burst(x,y,n=18,bright=true){
    for(let i=0;i<n;i++){
      const a=Math.random()*Math.PI*2;
      const sp=(Math.random()*2.4+1.1)*(bright?1.05:.95);
      P.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:1,r:Math.random()*3+1,bright});
    }
  }

  // ----- Game state -----
  const LS_BEST="noir_pulse_best_v1";
  let best=+localStorage.getItem(LS_BEST)||0;

  let running=false, paused=false;
  let hard=true;

  let timeLeft=30.0;
  let score=0;

  // Player: a ring in center, tap = flip polarity, hold = slow time (cost)
  let polarity=1;           // 1 = white, -1 = dark
  let hold=false;
  let slow=0;               // 0..1

  // Orbs: must match polarity when they reach ring
  const orbs=[];
  let spawn=0;
  let combo=0;

  // Ring geometry
  function ring(){
    return {
      x: W*0.5,
      y: H*0.56,
      r: Math.min(W,H)*0.115,
    };
  }

  // ----- Input -----
  function flip(){
    if(!running || paused) return;
    polarity *= -1;
    combo = Math.max(0, combo-1);
    const R=ring();
    burst(R.x, R.y, 18, polarity===1);
    try{ TG?.HapticFeedback?.impactOccurred?.('light'); }catch(e){}
  }

  el.game.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    if(el.ov.style.display!=="none"){ start(); return; }
    hold=true;
  }, {passive:false});
  el.game.addEventListener('pointerup', (e)=>{
    e.preventDefault();
    if(!running || paused) return;
    if(hold){
      // quick tap vs hold: if released fast, flip
      // we detect by slow not yet built up
      if(slow < 0.15) flip();
    }
    hold=false;
  }, {passive:false});
  el.game.addEventListener('pointercancel', ()=>{hold=false;}, {passive:true});

  // ----- Buttons -----
  el.play.addEventListener('click', start);
  el.mode.addEventListener('click', ()=>{
    hard=!hard;
    el.mode.textContent = hard ? "HARD" : "SOFT";
  });
  el.pause.addEventListener('click', ()=>{
    if(!running) return;
    paused=!paused;
    el.pause.textContent = paused ? "▶" : "⏸";
  });
  el.send.addEventListener('click', ()=>send(true));

  window.addEventListener('keydown', (e)=>{
    if(e.code==="Space"){ e.preventDefault(); (el.ov.style.display!=="none") ? start() : (paused=!paused, el.pause.textContent=paused?"▶":"⏸"); }
  });

  // ----- Core mechanics -----
  function start(){
    running=true; paused=false;
    timeLeft=30.0; score=0; combo=0;
    polarity=1; hold=false; slow=0;
    orbs.length=0; spawn=0;
    el.ov.style.display="none";
    el.pause.textContent="⏸";
    updateHUD();
  }

  function end(){
    running=false; paused=false;
    best = Math.max(best, score);
    localStorage.setItem(LS_BEST, best);
    send(false);

    el.ov.style.display="grid";
    el.play.textContent="PLAY";
    // minimal text: no extra UI changes
  }

  function send(manual){
    const data = JSON.stringify({ game:"noir_pulse", score, best, hard, manual:!!manual, ts:Date.now() });
    try{
      if(TG?.sendData){
        TG.sendData(data);
        TG?.HapticFeedback?.impactOccurred?.('light');
      }
    }catch(e){}
  }

  function updateHUD(){
    el.s.textContent = String(score);
    el.b.textContent = String(best);
    el.t.textContent = timeLeft.toFixed(1);
  }

  function spawnOrb(){
    const R=ring();
    const fromTop = Math.random() < 0.55;
    const x = R.x + (Math.random()*2-1)*Math.min(W,H)*0.28;
    const y = fromTop ? -40*dpr : H + 40*dpr;
    const dirY = fromTop ? 1 : -1;

    // type: +1 (white) or -1 (dark)
    let type = (Math.random() < (hard?0.52:0.58)) ? 1 : -1;
    // occasional “glitch” (faster)
    const glitch = Math.random() < (hard?0.22:0.15);

    orbs.push({
      x, y, vx: (R.x-x)*0.18,
      vy: dirY*(hard?rand(180,240):rand(150,210))*(glitch?1.35:1),
      type,
      r: rand(12,18)*dpr,
      glitch
    });
  }

  function rand(a,b){return a+Math.random()*(b-a)}

  // collision when orb reaches ring radius band
  function step(dt){
    if(!running || paused) return;

    // hold => slow time, but costs score potential (reduces points later)
    const targetSlow = hold ? 1 : 0;
    slow += (targetSlow - slow) * Math.min(1, dt*10);
    const timeScale = 1 - slow*0.55;     // slow motion
    const R=ring();

    timeLeft -= dt*timeScale;
    if(timeLeft<=0){ timeLeft=0; updateHUD(); end(); return; }

    // spawn rate
    spawn -= dt*timeScale;
    if(spawn<=0){
      spawnOrb();
      const base = hard ? 0.52 : 0.65;
      spawn = base * (0.90 + Math.random()*0.25);
    }

    // move orbs
    for(let i=orbs.length-1;i>=0;i--){
      const o = orbs[i];
      o.x += o.vx * dt * timeScale;
      o.y += o.vy * dt * timeScale;

      // distance to ring
      const dx=o.x-R.x, dy=o.y-R.y;
      const d=Math.hypot(dx,dy);

      // hit zone
      const band = R.r*0.18 + o.r;
      if(d <= band){
        const ok = (o.type === polarity);
        if(ok){
          combo++;
          const mult = 1 + Math.min(6, Math.floor(combo/3))*0.25;
          const add = Math.round((10 + (o.glitch?6:0)) * mult * (hold?0.85:1));
          score += add;
          burst(R.x, R.y, 22, true);
          try{ TG?.HapticFeedback?.impactOccurred?.('light'); }catch(e){}
        } else {
          combo = 0;
          score = Math.max(0, score-18);
          burst(R.x, R.y, 18, false);
          el.app.classList.add('shake');
          setTimeout(()=>el.app.classList.remove('shake'),180);
          try{ TG?.HapticFeedback?.impactOccurred?.('heavy'); }catch(e){}
        }
        orbs.splice(i,1);
        continue;
      }

      // offscreen cleanup
      if(o.y < -120*dpr || o.y > H + 120*dpr) orbs.splice(i,1);
    }

    updateHUD();
  }

  // ----- Render -----
  function draw(){
    // game
    g.clearRect(0,0,W,H);

    // subtle grid / vignette
    g.globalAlpha = 1;
    g.fillStyle = "rgba(255,255,255,.02)";
    for(let x=0; x<W; x+=Math.floor(90*dpr)){
      g.fillRect(x,0,1,H);
    }
    for(let y=0; y<H; y+=Math.floor(90*dpr)){
      g.fillRect(0,y,W,1);
    }

    // ring
    const R=ring();
    const ringGlow = polarity===1 ? 0.22 : 0.12;
    g.save();
    g.beginPath();
    g.arc(R.x,R.y,R.r,0,Math.PI*2);
    g.strokeStyle = `rgba(255,255,255,${0.40})`;
    g.lineWidth = 3*dpr;
    g.shadowBlur = 26*dpr;
    g.shadowColor = `rgba(255,255,255,${ringGlow})`;
    g.stroke();
    g.restore();

    // inner pulse
    const pulse = 0.65 + 0.35*Math.sin(performance.now()/210);
    g.save();
    g.beginPath();
    g.arc(R.x,R.y,R.r*(0.38 + 0.06*pulse),0,Math.PI*2);
    g.fillStyle = polarity===1 ? `rgba(255,255,255,${0.10+0.08*pulse})` : `rgba(255,255,255,${0.05+0.05*pulse})`;
    g.fill();
    g.restore();

    // orbs
    for(const o of orbs){
      g.save();
      g.beginPath();
      g.arc(o.x,o.y,o.r,0,Math.PI*2);
      const a = o.type===1 ? 0.88 : 0.30;
      g.fillStyle = `rgba(255,255,255,${a})`;
      g.shadowBlur = 18*dpr;
      g.shadowColor = `rgba(255,255,255,${o.type===1?0.22:0.12})`;
      g.fill();
      g.restore();
    }

    // hold indicator (minimal)
    if(running && !paused && slow>0.02){
      g.save();
      g.globalAlpha = 0.20*slow;
      g.fillStyle = "rgba(255,255,255,.35)";
      g.fillRect(0,0,W,H);
      g.restore();
    }

    // fx particles
    fx.clearRect(0,0,W,H);
    for(let i=P.length-1;i>=0;i--){
      const p=P[i];
      p.life -= 0.016*1.15; // approx, will look fine
      p.x += p.vx*2.2*dpr;
      p.y += p.vy*2.2*dpr;
      p.vx *= 0.985;
      p.vy *= 0.985;
      if(p.life<=0){P.splice(i,1); continue;}
      fx.globalAlpha = Math.max(0,p.life);
      fx.beginPath();
      fx.arc(p.x,p.y,p.r*dpr,0,Math.PI*2);
      fx.fillStyle = p.bright ? "rgba(255,255,255,.95)" : "rgba(255,255,255,.35)";
      fx.shadowBlur = 16*dpr;
      fx.shadowColor = p.bright ? "rgba(255,255,255,.25)" : "rgba(255,255,255,.14)";
      fx.fill();
      fx.shadowBlur=0;
    }

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);

  // ----- Main loop -----
  let last=performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last=now;
    step(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // initial overlay
  el.play.textContent="PLAY";
  el.ov.style.display="grid";
})();
</script>
</body>
</html>
